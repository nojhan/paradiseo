<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; Linux 2.4.7-10 i686) [Netscape]">
   <title>Genetic Engine</title>
</head>
<body text="#000000" link="#0000EF" vlink="#51188E" alink="#FF0000" background="beige009.jpg">
<b><font color="#CC0000">General: </font></b><a href="eoTopDown.html">Algorithm-Based</a>
- <a href="eoBottomUp.html">Component-Based</a> - <a href="eoProgramming.html">Programming
hints</a> - <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/index.html">EO
documentation
<hr WIDTH="100%"></a></font></font><font color="#CC0000">Local: </font></b><a href="#introduction">Introduction</a>&nbsp;
- <a href="#selection">Selection</a> - <a href="#replacement">Replacement</a>
- <a href="#general">General Replacement</a> - <a href="#popular">Popular
evolution engines</a> - <a href="#tournament">Tournaments</a> - <a href="#merge">Merge</a>
- <a href="#reduce">Reduce</a> - <a href="#howmany">HowMany</a> - <a href="#SAD">SurviveAndDie</a>
<hr WIDTH="100%">
<center>
<h1>
<b><font color="#CC0000">Evolution Engine</font></b></h1></center>

<hr WIDTH="100%">
<br><a NAME="introduction"></a><b><font color="#000099"><font size=+2>Evolution
Engines</font></font></b>
<p>The term <b><font color="#FF6600">evolution engine</font></b> denotes
the different parts of an Evolutionary Algorithm that simulate the Darwinism:
<center>
<p><i><font color="#009900">The fittest individuals are more likely to
reproduce and survive.</font></i></center>

<p>Darwinism takes place in two different phases of an EA, though in many
<a href="#popular">popular
variants</a>, only one phase is activated.
<p><a href="#selection">Selection</a> is the Darwinistic choice of parents
that will be allowed to <b><font color="#009900">reproduce</font></b><font color="#CC33CC">.</font>
<br><a href="#replacement">Replacement</a> takes place after reproduction,
and is the Darwinistic choice of those individuals that will <b><font color="#009900">survive</font></b>,
i.e. become the parents of the next generation.
<p>Both selection and replacement will be discussed in turn, before some
helper classes that are used within selection and replacement procedures
are presented.
<p>
<hr WIDTH="100%"><a NAME="selection"></a><b><font color="#000099"><font size=+2>Selection</font></font></b>
<p>The very beginning of the generation loop is the selection phase, where
some individuals from the population are chosen to become the parents,
to be later modified by the variation operators and become the offspring.
This is the first step of the <font color="#009900">artificial Darwinism</font>,
where the <i><font color="#FF6600">fittest individuals are allowed to reproduce</font></i>.
<br>Conceptually, there are two distinct ways to choose the lucky ones:
one by one from the very same population (i.e. with replacement), which
means that at the extreme the same individual can be chosen every time;
or as a whole, in some sort of batch procedure. Of course, repeated selection
of one individual results in a batch selection!
<p>There are hence two basic EO classes for selection: <font color="#009900">eoSelectOne</font>
and <font color="#009900">eoSelect</font>, with different interfaces.
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">eoSelectOne: </font><font color="#FF0000">The
interface</font></b>
<p>The abstract class for selection of a single individual from a population
is <font color="#009900">eoSelectOne</font>, and the interface for its
<tt><font color="#993300">operator()</font></tt>
is
<center>
<p><b><tt><font color="#993300">const EOT &amp; operator()(const eoPop&lt;EOT>&amp;
_parents)</font></tt></b></center>

<p>which you could have guessed from the inheritance tree for class <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_select_one.html">eoSelectOne</a></font></font></b>.,
as you see there that <font color="#009900">eoSelectOne</font> derives
from <tt><font color="#993300">class eoUF&lt;const eoPop&lt;EOT>&amp;,
const EOT&amp;></font></tt>.
<br>This means that it takes <font color="#FF6600">1 population</font>
(without the right to modify it - see the <b><tt><font color="#993300">const</font></tt></b>
keyword in argument) and returns a const reference to an individual (again,
the <b><tt><font color="#993300">const</font></tt></b> keyword ensures
that nothing will happen to the individual in the population - remember
it returns a reference).
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">eoSelectOne: </font><font color="#FF0000">Instances</font></b>
<ul>
<li>
<b><tt><font color="#009900">eoDetTournamentSelect</font></tt></b> uses
the <a href="#detTournament">(deterministic) tournament</a> to choose one
individual. Its constructor has one parameter, the tournament size (integer
>= 2).</li>

<li>
<b><tt><font color="#009900">eoStochTournamentSelect</font></tt></b> uses
the <a href="#stochTournament">binary stochastic tournament</a> to choose
one individual. Its constructor has one parameter, the tournament rate
(real in [0.5,1]).</li>

<li>
&nbsp;<b><tt><font color="#009900">eoProportionalSelect</font></tt></b>
is the original <font color="#FF6600">roulette wheel</font> selection:
each parent is selected with a probability proportional to its fitness.</li>

<li>
<b><tt><font color="#009900">eoRandomSelect</font></tt></b> is the <font color="#FF6600">random</font>
selection and should give bad results! At the moment, it selects one individual
uniformly, but it would be easy to use any probability distribution.</li>
</ul>

<hr WIDTH="50%">
<br><b><font color="#000099">eoSelect: </font><font color="#FF0000">The
interface</font></b>
<p>The abstract class for batch selection of a&nbsp; whole set of individuals
from a population is <font color="#009900">eoSelect</font>, and the interface
for its
<tt><font color="#993300">operator()</font></tt> is
<center>
<p><b><tt><font color="#993300">void operator()(const eoPop&lt;EOT>&amp;
_source, eoPop&lt;EOT>&amp; _dest)</font></tt></b></center>

<p>which you could have guessed from the inheritance tree for class <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_select.html">eoSelect</a></font></font></b>.,
as you see there that <font color="#009900">eoSelect</font> derives from
<tt><font color="#993300">class
eoBF&lt;const eoPop&lt;EOT>&amp;, eoPop&lt;EOT>&amp;, void></font></tt>.
<br>This means that it takes <font color="#FF6600">2 populations</font>,
and fills the second one with individuals from the first one without modifying
it (see the <b><tt><font color="#993300">const</font></tt></b> keyword).
This raises two questions:
<ul>
<li>
How does it know how many individuals to select?</li>

<li>
How to use repeated selection of one individual (see above the <font color="#009900">eoSelectOne</font>
class)?</li>
</ul>

<hr WIDTH="50%">
<br><b><font color="#000099">eoSelect: </font><font color="#FF0000">HowMany</font></b>
<p>There are two ways an&nbsp; can derive the number of individuals it
has to select: either it is a fixed number, or it is some percentage of
the source population size (any positive real number). In both case, this
must be passed to the constructor. In most instances, however, the constructor
will accept a real number (double) and a boolean indicating whether this
real number should be used as an absolute integer or as a rate, thanks
to the <a href="#howmany">eoHowMany</a> class.
<p><b><font color="#FF0000">Note</font></b>: an <font color="#009900">eoSelect</font>
can select more individuals than there are in the original population.
It is the job of the <font color="#009900">replacement</font> to ensure
that the population size does not grow along the generations.
<p>
<hr WIDTH="50%"><b><font color="#000099">eoSelectMany: </font><font color="#FF0000">Encapsulating
eoSelectOne</font></b>
<p>It is clear that repeated selection of a single individual is a way
to do batch selection. This is why it is possible to encapsulate an object
of class <font color="#009900">eoSelectOne</font> into an object of class
<font color="#009900">eoSelect</font>
using the class <font color="#009900">eoSelectMany</font>. Class <font color="#009900">eoSelectMany</font>
is derived from class <font color="#009900">eoSelect</font> and takes in
its constructor an <font color="#009900">eoSelectOne</font> (plus the number
of individuals it should select, according to the <a href="#howmany">eoHowMany</a>
paradigm).
<p><b><font color="#FF0000">Note</font></b>: some procedures for selecting
a single individual require some pre-processing of the whole population
that takes place before any selection, and will be repeated identically
for every individual. The encapsulation of an&nbsp; into an&nbsp; allows
to call such technical processing only once through the use of method setup
of class . This method does nothing by default, but is mandatory
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">eoSelect: </font><font color="#FF0000">Other
instances</font></b>
<ul>
<li>
<b><tt><font color="#009900">eoDetSelect</font></tt></b> selects individuals
<b><font color="#FF6600">deterministically</font></b>,
i.e. starting from the best ones down to the worse ones. If the total number
to select is less than the size of the source populations, the best individuals
are selected once. If more individuals are needed after reaching the bottom
of the population, then the selection starts again at top. It the total
number required is N times that of the source size, all individuals are
selected exactly N times.</li>
</ul>
No other instances of <font color="#009900">eoSelect</font> that are not
encapsualtions of <font color="#009900">eoSelectOne</font> procedures are
avaiable as of today (Jan. 4 2001).
<br>
<hr WIDTH="100%">
<br><a NAME="replacement"></a><b><font color="#000099"><font size=+2>Replacement</font></font></b>
<p>The replacement phase takes plac<font color="#000000">e after the birth
of all offspring through </font>variation operators. This is the second
step of the <font color="#009900">artificial Darwinism</font>, where the
<i><font color="#FF6600">fittest
individuals are allowed to survive</font></i>.
<br>It can also be viewed on the algorithmic side as closing the generation
loop, i.e. building the population that will be the initial population
of next generation. That population will be <font color="#FF6600">built
upon the old parents and the new-born offspring</font>. In all algorithms
that come up with EO, the <font color="#FF6600">population size</font>
is supposed to be <font color="#FF6600">constant</font> from one generation
to the next one - though nothing stops you from writing an algorithm with
varying population size.
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">Replacement: </font><font color="#FF0000">The
interface</font></b>
<p>The abstract class for replacement procedures is the functor class
<font color="#009900">eoReplacement</font>,
and the interface for its <tt><font color="#993300">operator()</font></tt>
is
<center>
<p><b><tt><font color="#993300">void operator()(eoPop&lt;EOT>&amp; _parents,
eoPop&lt;EOT>&amp; _offspring)</font></tt></b></center>

<p>which you could have guessed from the inheritance tree for class <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_replacement.html">eoReplacement</a></font></font></b>.,
as you see there that <font color="#009900">eoReplacement</font> derives
from <tt><font color="#993300">class eoBF&lt;eoPop&lt;EOT>&amp;, eoPop&lt;EOT>&amp;,
void></font></tt>.
<br>This means that it takes <font color="#FF6600">2 populations</font>
(called, for obvious anthropomorphic reasons, _parents and _offspring :-)
and is free to modify both, but the resulting population should be placed
in the first argument (usually called_parents) to close the loop and go
to next generation.
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">Replacement: </font><font color="#FF0000">Instances</font></b>
<ul>
<li>
<b><tt><font color="#009900">eoGenerationalReplacement </font></tt></b>This
is the most straightforward replacement, called <font color="#FF6600">generational
replacement</font>: all offspring replace all parents (used in Holland's
and Goldberg's traditional GAs).&nbsp; It takes no argument, and supposes
that offspring and parents are of the same size (but does not check!).</li>

<br>&nbsp;
<li>
<a NAME="SSGA"></a><b><tt><font color="#009900">eoMergeReduce</font></tt></b>
This is one the basic types of replacement in EO. It has two major steps,
<font color="#FF6600">merging</font>
both populations of parents and offspring, and <font color="#FF6600">reducing</font>
this big population to the right size. It <font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_merge_reduce.html">contains
two objects</a></font></font> of respective types <b><font color="#009900"><a href="#merge">eoMerge</a></font></b>
and <b><font color="#009900"><a href="#reduce">eoReduce</a></font></b>
and you can probably guess what each of them actually does :-)</li>

<br>&nbsp;
<p>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>Available <font color="#FF6600">instances of eoMergeReduce</font> replacement
include
<ul>
<li>
<b><tt><font color="#009900">eoCommaReplacement</font></tt></b>, one of
the two standard strategies in <font color="#000000">Evolution Strategies</font>,
<b><font color="#FF6600">selects
the best offspring</font></b>. It is an
<b><tt><font color="#993300">eoMergeReduce(eoNoElitism,
eoTruncate)</font></tt></b>.</li>

<li>
<b><tt><font color="#009900">eoPlusReplacement</font></tt></b>, the other
standar<font color="#000000">d Evolution Startegies repla</font>cement,
where <b><font color="#FF6600">the best from offspring+parents</font></b>
become the next generation. It is an <b><tt><font color="#993300">eoMergeReduce(eoPlus,
eoTruncate)</font></tt></b>.</li>

<li>
<b><tt><font color="#009900">eoEPReplacement</font></tt></b>, used in th<font color="#000000">e
Evolutionary Programming historical </font>algorithm, does an EP stochastic
tournament among parents + offspring. It is an <b><tt><font color="#993300">eoMergeReduce(eoPlus,
eoEPReduce)</font></tt></b> and its constructor requires as argument T,
the size of the tournament (unsigned int).</li>
</ul>

<li>
<b><tt><font color="#009900">eoReduceMerge</font></tt></b> is another important
type of eoReplacement: the parents are first reduced, and then merged with
the offspring. Note that the parent population is reduced of the exact
number of offspring.</li>

<br>Though not mandatory, it is implicitely assumed that few offspring
have been generated. Hence, all derived replacement procedures of class
<b><tt><font color="#009900">eoReduceMerge</font></tt></b>
are termed <b><tt><font color="#009900">eoSSGAxxx</font></tt></b>, as they
are the ones to use in SteadyState Genetic Algorithm engine. This gives
the following <font color="#FF6600">instances of eoReduceMerge</font>:
<ul>
<li>
&nbsp;<b><tt><font color="#009900">eoSSGAWorseReplacement</font></tt></b>
in which the worse parents are killed and replaced by all offsprings (no
additional argument needed);</li>

<li>
<b><tt><font color="#009900">eoSSGADetTournamentReplacement</font></tt></b>
in which parents to be killed are chosen by a (reverse) determinitic tournament.
Additional parameter (in the constructor) is the tournament size, an <b><tt><font color="#993300">unsigned
int</font></tt></b>.</li>

<li>
<b><tt><font color="#009900">eoSSGAStochTournamentReplacement</font></tt></b>
in which parents to be killed are chosen by a (reverse) stochastic tournament.
Additional parameter (in the constructor) is the tournament rate, a <b><tt><font color="#993300">double</font></tt></b>.</li>
</ul>

<li>
<a NAME="SADreplacement"></a><b><tt><font color="#009900">eoSurviveAndDie</font></tt></b>
replacement strategies are a generalization of both the above that allows
strong elitist and eugenism in both the parent population and the offspring
population. The <b><tt><font color="#009900"><a href="#SAD">eoSurviveAndDie</a></font></tt></b>
building block takes one population, kills the worse and moves the best
to some safe place.&nbsp; The corresponding replacements apply an <b><tt><font color="#009900">eoSurviveAndDie</font></tt></b>
to the parents, another one to the offspring, and finally merges the remaining
parents and offspring before reducing the resulting population to the right
size. Available instances of <b><tt><font color="#009900">eoSurviveAndDieReplacement</font></tt></b>
are limited todayto the <b><tt><font color="#009900">eoDeterministicSaDReplacement</font></tt></b>,
the&nbsp; that uses a deterministic MergeReduce.</li>

<br>&nbsp;
<p>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p><b><font color="#FF0000">Note</font></b>: The basic use (and initial
motivation) for <b><tt><font color="#009900">eoSurviveAndDie</font></tt></b>
takes 2 arguments, an eoMergeReduce and a number of surviving parents.
It starts by copying the best parents to the new populations, then merges
the remaining parents with the offspring before reducing to the number
of remaining seats in the new population.</ul>

<hr WIDTH="50%">
<br><a NAME="weakelitism"></a><b><font color="#000099">Replacement: </font><font color="#FF0000">Adding
(weak) elitism</font></b>
<p>You can add what is called <font color="#FF6600">weak elitism</font>
to any replacement by encapsulating it into an <b><tt><font color="#009900">eoWeakElitismReplacement</font></tt></b>
object. Weak elitism ensures that the overall <font color="#FF6600">best
fitness</font> in the population <font color="#FF6600">will never decrease</font>:
if the best fitness in the new population is less than the best fitness
of the parent population, then the best parent is added back to the new
population, replacing the worse.
<p>Within EO, this is very easy to add:
<p>First, declare your replacement functor (here, generational, but it
can be any replacement object):
<br><b><tt><font color="#009900">eoGenerationalReplacement&lt;Indi> genReplace;</font></tt></b>
<br>Then wrap the weak elitism around it:
<br><b><tt><font color="#009900">eoWeakElitismReplacement&lt;Indi> replace(genReplace);</font></tt></b>
<br>and use now replace as your replacement procedure within your algorithm.
<p><font color="#FF0000">Note</font>: of course, adding weak elitism to
an elitist replacement makes no sense - but will not harm either :-)
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">Replacement: </font><font color="#FF0000">Test
file</font></b>
<p>The file <b><tt><font color="#993300">t-eoReplacement</font></tt></b>
in the <b><font color="#FF6600">test directory</font></b> implements all
above replacement procedures within a very simple and easy-to-monitor Dummy
EO class.
<p>
<hr WIDTH="100%">
<br><a NAME="general"></a><b><font color="#000099"><font size=+2>General
Replacement: eoReduceMergeReduce</font></font></b>
<p>In an attempt to unify all the well-known replacements, plus most of
the less-known-though-often-used, the <b><tt><font color="#009900">eoReduceMergeReduce</font></tt></b>
replacement has been designed, and supersedes all of the above instances.
<br>It allows to implement <b><font color="#FF0000">strong elistism</font></b>
(i.e. some parents survive, whatever their fitness and that of the offspring),
as well as multiple weak elistism (the best parents are put back in the
next population if they outperform the best offspring).
<p>Basically, an <b><tt><font color="#009900">eoReduceMergeReduce</font></tt></b>
starts by eventually preserving the (strong) elite parents, proceeds by
reducing both the parent and offspring populations, merges those populations,
and eventually reduces the resulting populations (augmented with the elite
parents) to the right size. Last, the weak elitism is taken care of if
necessary.
<br>The following image, taken from the graphical interface of EASEA, somehow
demonstrates the different parameters of an <b><tt><font color="#009900">eoReduceMergeReduce.</font></tt></b>
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">eoReduceMergeReduce: </font><font color="#FF0000">The&nbsp;
interface</font></b>
<br>Of course the interface is that of eoReplacement. Let's concentrate
on the constructor.
<p>The constructor takes 6 arguments:
<ol>
<li>
<b><tt><font color="#993300">eoHowMany elite</font></tt></b> determines
the number of parents to be treated as elite (actual behavior determined
by next parameter) using the <a href="#howmany">eoHowMany</a> behavior.</li>

<li>
<b><tt><font color="#993300">bool strongElitism</font></tt></b> tells whether
the elite above corresponds to strong (true) or false(weak) elitism.</li>

<br><b><font color="#FF0000">Note</font></b>: the case of no elitism is
obtained by setting elite to 0
<li>
<b><tt><font color="#993300">eoHowMany reducedParents </font></tt></b>gives
the number of parents remaining after reducing them</li>

<br><b><font color="#FF0000">Note</font></b>: 0 means that no parent survive
(except the possible elite), as in <b><tt><font color="#009900">eoCommaReplacement</font></tt></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-1 is used inside <b><tt><font color="#009900">eoSSGAReplacement</font></tt></b>s
(one parent is killed to make room for the newborn)
<li>
<b><tt><font color="#993300">eoReduce&lt;EOT> &amp; reduceParents</font></tt></b>
indicates how the parents will be reduced (see <a href="#reduce">available
instances</a>).</li>

<li>
<b><tt><font color="#993300">eoHowMany reducedOffspring </font></tt></b>gives
the number of offspring remaining after reducing them</li>

<br><b><font color="#FF0000">Note</font></b>: 0 is impossible (no evolution!!!)
<li>
<b><tt><font color="#993300">eoReduce&lt;EOT> &amp; reduceOffspring</font></tt></b>
indicates how the offspring will be reduced (see <a href="#reduce">available
instances</a>).</li>

<li>
<b><tt><font color="#993300">eoReduce&lt;EOT> &amp; reduceFinal</font></tt></b>
indicates how the merged reduced-parents/reduced-offspring will be reduced
(see <a href="#reduce">available instances</a>).</li>

<br><b><font color="#FF0000">Note</font></b>: the number of individuals
remaining after that reduction is of course the original size of the population.</ol>
All popular evolution engines use some replacement procedure that can be
viewed as an instance of an <b><tt><font color="#009900">eoReduceMergeReduce</font></tt></b>.
<br>Moreover, a <b><font color="#FF0000">parser-based</font></b> input
of a general&nbsp; is proposed in file do/make_checkpoint.h.
<br>
<hr WIDTH="100%">
<br><a NAME="popular"></a><b><font color="#000099"><font size=+2>Popular
evolution engines</font></font></b>
<p>The most popular evolution engines are listed below, together with the
way to use them in EO. If you don't find your particuler algorithm, please
send it to us, and we might include it here! In the following, P will denote
the number of individuals in the initial population.
<ul>
<li>
<a NAME="GGA"></a><b><font color="#000099">Generational Genetic Algorihtm</font></b><font color="#000000">:
popularized by Holland (75) and Goldberg (89), it uses</font></li>

<br><font color="#FF0000">Number of offspring:&nbsp;</font><font color="#000000">
P</font>
<br><font color="#FF0000">Selection:</font><font color="#000000"> Proportional
(the historical roulette wheel) </font><b><font color="#FF6600">when maximizing
a positive scalar fitness</font></b><font color="#000000">, ranking or
tournament (stochatic or deterministic) in all cases.</font>
<br><font color="#FF0000">Replacement:</font><font color="#000000"> Generational.</font>
<br><font color="#FF0000">Remark:</font><font color="#000000"> You could
use also the </font><b><tt><font color="#009900">eoCommaReplacement</font></tt></b><font color="#000000">,
with exactly the same result as there are as many offspring as we need
indiviudals in the next population. And using the </font><b><tt><font color="#009900">eoSSGAWorseReplacement</font></tt></b><font color="#000000">
would also give the same result, but would be very inefficient!</font>
<br><font color="#000000">You can also add <a href="#weakelitism">weak
elitism</a> to preserve the best individual.</font>
<li>
<a NAME="SSGA"></a><b><font color="#000099">Steady-State Genetic Algorithm</font></b><font color="#000000">:
widely used in GA/GP community</font></li>

<br><font color="#FF0000">Number of offspring:&nbsp;</font><font color="#000000">
small (historically, 1)</font>
<br><font color="#FF0000">Selection:</font><font color="#000000"> tournament
(you can use ranking or proportional, but it will be rather inefficient).</font>
<br><font color="#FF0000">Replacement:</font><font color="#000000"> An
eoSSGAxxxReplacement.</font>
<br><font color="#FF0000">Remark:</font><font color="#000000"> You can
also use the eoPlusReplacement, but you divert from the original SSGA</font>
<li>
<a NAME="ESPlus"></a><b><font color="#000099">(MU+Lambda)-Evolution Strategy</font></b><font color="#000000">:
The elitist ES strategy (Rechenberg 71 and Schwefel 81)</font></li>

<br><font color="#FF0000">Number of offspring:&nbsp;</font><font color="#000000">
Any</font>
<br><font color="#FF0000">Selection:</font><font color="#000000"> eoDetSelect
(batch deterministic).</font>
<br><font color="#FF0000">Replacement:</font><font color="#000000"> eoPlusReplacement</font>
<br><font color="#FF0000">Remark:</font><font color="#000000"> You could
also use eoEPReplacement, to smoothen the selective pressure during replacement,
thus getting close to EP evolution engine</font>
<li>
<a NAME="ESComma"></a><b><font color="#000099">(MU,Lambda)-Evolution Strategy</font></b><font color="#000000">:
The non-elitist ES strategy</font></li>

<br><font color="#FF0000">Number of offspring:&nbsp;</font><font color="#000000">
> P</font>
<br><font color="#FF0000">Selection:</font><font color="#000000"> eoDetSelect
(batch deterministic).</font>
<br><font color="#FF0000">Replacement:</font><font color="#000000"> eoCommaReplacement</font>
<br><font color="#FF0000">Remark:</font><font color="#000000"> You can
also add <a href="#weakelitism">weak elitism</a> to preserve the best individual
- though you'd probably use the plus strategy if you want (strong) elitism.</font>
<li>
<a NAME="EP"></a><b><font color="#000099">Evolutionary Programming</font></b><font color="#000000">:
The historical method of L. Fogel (65)</font></li>

<br><font color="#FF0000">Number of offspring:&nbsp;</font><font color="#000000">
P</font>
<br><font color="#FF0000">Selection:</font><font color="#000000"> eoDetSelect
(batch deterministic). Every individual reproduces exactly once.</font>
<br><font color="#FF0000">Replacement:</font><font color="#000000"> eoEPReplacement,
though one historical replacement was the determnistic replacement - i.e.
in EO the eoPlusReplacement).</font>
<br><font color="#FF0000">Remark:</font><font color="#000000"> Close to
an (P+P)-ES</font>
<li>
<a NAME="General"></a><font color="#FF0000">You name it :-)</font><font color="#000000">:
you can of course choose whatever combination you like - respecting a few
constraints and common-sense remarks. For instance, eoProportionalSelect
should be used only when maximizing a positive fitness, eoCommaReplacement
requires more offspring than parents, and, over all, existing EO algorithms
wirk with fixed size population - and it is your responsability to use
a cmbinatino of selection/replacement that fulfills this requirement (or
to create your own eoAlgo that handles varying size populations).</font></li>
</ul>

<hr WIDTH="100%">
<br><a NAME="tournament"></a><b><font color="#000099"><font size=+2>Tournaments</font></font></b>
<p>Tournaments are an easy and quick way to <b><font color="#FF6600">select</font></b>
individuals within a population based on simple comparisons. Though usually
based on fitness comparisons, they can use any comparison operator.
<br>In EO, there are two variants of tournaments used to select one single
individual, namely <b><tt><font color="#009900">Deterministic Tournament</font></tt></b>
and <b><tt><font color="#009900">Stochastic Tournament</font></tt></b>,
that are used in selection and in replacement procedures, and a global
tournament-based selection of a whole bunch of individuals, the <b><tt><font color="#009900">EP
Tournament</font></tt></b>. Though the single-selection tournaments can
be repeated to select more than one individual, and the batch tournament
selection can be used to select a single individual, both uses are probably
a waste of CPU time.
<ul>
<li>
<a NAME="detTournament"></a><b><tt><font color="#009900">Deterministic
Tournament</font></tt></b> of size T returns the best of T uniformly chosen
individuals in the population. Its size T should be an integer >= 2. It
is implemented in the <b><tt><font color="#009900">eoDetTournamentSelect</font></tt></b>
class, a sub-class of eoSelectOne, as well as in the <b><tt><font color="#009900">eoDetTournamentTruncate</font></tt></b>
class that repeatidly removes from the population the "winner" of the inverse
tournament.&nbsp; These objects use the C++ function determinitic_tournament
in&nbsp; <a href="../../doc/html/selectors_h-source.html">selectors.h</a>.</li>

<li>
<a NAME="stochTournament"></a><b><tt><font color="#009900">Stochastic Tournament</font></tt></b>
of rate R first choses two individuals from the population, and selects
the best one with probability R (the worse one with probability 1-R). Real
parameter R should be in [0.5,1]. It is implemented in the <b><tt><font color="#009900">eoStochTournamentSelect</font></tt></b>
class, a sub-class of eoSelectOne, as well as in the <b><tt><font color="#009900">eoStochTournamentTruncate</font></tt></b>
class that repeatidly removes from the population the "winner" of the inverse
tournament.&nbsp; These objects use the C++ function determinitic_tournament
in&nbsp; <a href="../../doc/html/selectors_h-source.html">selectors.h</a>.</li>

<br><b><font color="#FF0000">Note</font></b>: A stochastic tournament with
rate 1.0 is strictly identical to a deterministic tournament of size 2.
<li>
<a NAME="EPTournament"></a><b><tt><font color="#009900">EP Tournament</font></tt></b>
of size T is a global tournament: it works by assigning a score to all
individuals in the population the following way: starting with a score
of 0, each individual I is "opposed" T times to a uniformly chosen individual.
Everytime I wins, its score in incremented by 1 (and by 0.5 for every draw).
The individuals are then selected deterministically based on their scores
from that procedure. The <b><tt><font color="#009900">EP Tournament</font></tt></b>
is implemented in the&nbsp; <b><tt><font color="#009900">eoEPReduce</font></tt></b>
truncation method used in the <b><tt><font color="#009900">eoEPReplacement</font></tt></b>
procedure.</li>

<br><b><font color="#FF0000">Note</font></b>: whereas both the determinitic
and the stochastic tournament select one individual, the EP tournament
is designed for batch selection. Of course it could be used to select a
single individual, but at a rather high computational cost.</ul>

<p><br>
<hr WIDTH="100%">
<br><a NAME="merge"></a><b><font color="#000099"><font size=+2>Merging
populations</font></font></b>
<p>In replacement procedures, one frequently needs to merge two populations
(computed form old parents and new-born offspring). Classes derived from
the abstract class eoMerge are written for that purpose.
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">eoMerge</font></b>: <b><font color="#FF0000">interface</font></b>
<br>The abstract class for merging procedures is the functor class
<font color="#009900">eoMerge</font>,
and the interface for its <tt><font color="#993300">operator()</font></tt>
is
<center>
<p><b><tt><font color="#993300">void operator()(const eoPop&lt;EOT>&amp;
_parents, eoPop&lt;EOT>&amp; _offspring)</font></tt></b></center>

<p>which you could have guessed from the inheritance tree for class <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_merge.html">eoMerge</a></font></font></b>,
as you see there that <font color="#009900">eoMerge</font> derives from
<br><tt><font color="#993300">class eoBF&lt;const eoPop&lt;EOT>&amp;, eoPop&lt;EOT>&amp;,
void></font></tt>.
<br>This means that it takes <font color="#FF6600">2 populations</font>
and modifies the seond one by adding some individuals from the first one
(which is supposed to remain <b><tt><font color="#993300">const</font></tt></b>ant).
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">eoMerge</font></b>: <b><font color="#FF0000">instances</font></b>
<br>Available <font color="#FF6600">instances of eoMerge</font> objects
are <b><tt><font color="#009900">eoPlus</font></tt></b>, that simply adds
the parents to the offspring, or <b><tt><font color="#009900">eoElitism</font></tt></b>,
that adds only some of the (best) parents to the offspring. A special case
of eoElistism is <b><tt><font color="#009900">eoNoElitism</font></tt></b>,
an eoMerge that does nothing.
<p>
<hr WIDTH="100%">
<br><a NAME="reduce"></a><b><font color="#000099"><font size=+2>Reducing
populations</font></font></b>
<p>The other useful component of replacement procedures, <font color="#009900">eoReduce</font>,
<font color="#FF6600">kills
some individuals</font> from a given population.
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">eoReduce</font></b>: <b><font color="#FF0000">interface</font></b>
<br>The abstract class for reducing procedures is the functor class
<font color="#009900">eoReduce</font>,
and the interface for its <tt><font color="#993300">operator()</font></tt>
is
<center>
<p><b><tt><font color="#993300">void operator()(eoPop&lt;EOT>&amp; _parents,
unsigned int new_size)</font></tt></b></center>

<p>which you could have guessed from the inheritance tree for class <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_reduce.html">eoReduce</a></font></font></b>,
as you see there that <font color="#009900">eoReduce</font> derives from
<br><tt><font color="#993300">class eoBF&lt;eoPop&lt;EOT>&amp;, unsigned
int, void></font></tt>.
<br>An <font color="#009900">eoReduce</font> shoud take a<font color="#FF6600">
population</font> and shrink it to the required size.
<br>
<hr WIDTH="50%">
<br><b><font color="#000099">eoReduce</font></b>: <b><font color="#FF0000">instances</font></b>
<br>Available <font color="#FF6600">instances of eoReduce</font> are
<ul>
<li>
<b><tt><font color="#009900">eoTruncate</font></tt></b>, deterministically
kills the worse individuals, keeping only the required number. It starts
by sorting teh populations, and hence does <font color="#FF6600">modify
its order</font>.</li>

<li>
<b><tt><font color="#009900">eoLinearTruncate</font></tt></b>, deterministically
kills the worse individuals, keeping only the required number. It does
so by repeatedly removing the worsr individual. Hence does <font color="#FF6600">not
modify its order</font>, but takes longer time than <b><tt><font color="#009900">eoTruncate</font></tt></b>
in case of many offspring.</li>

<li>
<b><tt><font color="#009900">eoEPReduce</font></tt></b>, uses the <a href="#EPtournament">EP
stochastic tournament</a> to reduce the population. It requires an additinal
argument, the tournament size.</li>

<li>
<b><tt><font color="#009900">eoDetTournamentTruncate</font></tt></b> uses
inverse deterministic tournament to repeatidly kill one individual until
the propoer size is reached. As <b><tt><font color="#009900">eoLinearTruncate</font></tt></b>,
it might take some time in the case of many offspring. It requires the
size of the tournament (<b><tt><font color="#993300">unsigned int</font></tt></b>)
as parameter in the constructor (default is 2).</li>

<li>
<b><tt><font color="#009900">eoStochTournamentruncate</font></tt></b>&nbsp;
uses inverse stochastic tournament to repeatidly kill individuals from
the population. It requires the rate of the tournament (<b><tt><font color="#993300">double</font></tt></b>)
as parameter in the constructor (default is 0.75).</li>
</ul>

<hr WIDTH="100%">
<br><a NAME="howmany"></a><b><font color="#000099"><font size=+2>eoHowMany:
Choosing a number of individuals</font></font></b>
<p>Many classes in selection/replacement procedures will handle a number
of individuals that may either be fixed or be related to some argument-population
size.
<br>Of course, it is possible to write different classes that will only
differ by the way they compute the number of individuals they have to treat,
as it is done for selectors with the two classes <font color="#009900">eoSelectPerc</font>
and <font color="#009900">eoSelectNumber</font> (it could also have been
possible to have some pure abstrat class and implement the computation
of the number of individuals to treat in some derived classes).
<br>However, the class <b><tt><font color="#993300">eoHowMany</font></tt></b>
allows one to handle in a single class three different behaviors when given
a poopulatio size as argument:
<ul>
<li>
return a given rate of the argument population size</li>

<li>
return an absolute (unsigned) integer, whatever the argument population
size</li>

<li>
return the argument population size minus a given number</li>
</ul>

<hr WIDTH="50%">
<br><b><font color="#000099">eoHowMany</font></b>: <b><font color="#FF0000">interface</font></b>
<br>The class interface for its <tt><font color="#993300">operator()</font></tt>
is
<center>
<p><b><tt><font color="#993300">unsigned int operator()(unsigned int _pop_size)</font></tt></b></center>

<p>which you could have guessed from the inheritance tree for class <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_how_many.html">eoHowMany</a></font></font></b>,
as you see there that <b><tt><font color="#993300">eoHowMany</font></tt></b>
derives from
<br><tt><font color="#993300">class eoUF&lt;unsigned int, unsigned int></font></tt>.
<p>It has 3 possible constructors, that determine its behavior:
<ul>
<li>
<b><tt><font color="#993300">eoHowMany(double _rate, bool _interpret_as_rate
= true)</font></tt></b> where <b><tt><font color="#993300">_rate</font></tt></b>
is by default the fixed rate of behavior 1 above. However, if the boolean
second argument is false, the rate is transformed into a positive integer,
and is used for behavior 2 above</li>

<li>
<b><tt><font color="#993300">eoHowMany(int _combien)</font></tt></b>: if
<b><tt><font color="#993300">_combien</font></tt></b>
is positive, it is the absolute number of behavior 2 above, and if <b><tt><font color="#993300">_combien</font></tt></b>
is negative, its absolute value is used to decrease the argument population
in behavior 3 above</li>

<li>
<b><tt><font color="#993300">eoHowMany(unsigned int _combien)</font></tt></b>:
<b><tt><font color="#993300">_combien</font></tt></b>
(positive!)&nbsp; is the absolute number of behavior 2 above. <b><font color="#FF6600">Note</font></b>
that this constructor is mandatory to avoid ambiguity, as an unsigned int
can be casted to either an int or a double.</li>
</ul>
It is used in <font color="#009900">eoSelectMany</font> (which supersedes
<font color="#009900">eoSelectPerc</font>
and <font color="#009900">eoSelectNumber</font>, but they are left there
for tutorial reasons!) as well as in many <a href="#reduce">truncation</a>
methods, and it is used a lot in the eoGeneralReplacement construct.
<p>
<hr WIDTH="100%">
<br><a NAME="SAD"></a><b><font color="#000099"><font size=+2>Survive and
Die</font></font></b>
<br>This class is highly politically incorrect: it implements strong elitism
and eugenism :-)
<br>It starts by killing the worse individuals from the source argument,
then appends the best ones to the destination argument and removes them
from the source argument. It is used in <b><tt><a href="#SADreplacement">eoSurviveAndDieReplacement</a></tt></b>,
where the same dest is used successively for the parents and the offspring.
<p><b><font color="#000099">eoSurviveAndDie</font></b>: <b><font color="#FF0000">interface</font></b>
<br>The class interface for its <tt><font color="#993300">operator()</font></tt>
is
<center>
<p><b><tt><font color="#993300">void operator()(eoPop&lt;EOT>&amp; _source,
eoPop&lt;EOT>&amp; _dest)</font></tt></b></center>

<p>which you could have guessed from the inheritance tree for class <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_survive_and_die.html">eoSurviveAndDie</a></font></font></b>,
as you see there that <b><tt><font color="#993300">eoSurviveAndDie</font></tt></b>
derives from <tt><font color="#993300">class eoBF&lt;eoPop&lt;EOT>&amp;,
eoPop&lt;EOT>&amp;, void></font></tt>.
<p>Its constructor takes 3 argumenrts:
<center>
<p><b><tt><font color="#993300">eoHowMany(double _survive, double _die,
bool _interpret_as_rate = true)</font></tt></b></center>

<p>to indicate how many (or what proportion, according to <b><tt><font color="#993300">_interpret_as_rate</font></tt></b>)
of the source should be copied to the dest population, and how many (or
what proportion, according to <b><tt><font color="#993300">_interpret_as_rate</font></tt></b>)&nbsp;
should be erased from the source.
<p>
<hr WIDTH="100%"><b><font color="#CC0000">Local: </font></b><a href="#introduction">Introduction</a>&nbsp;
- <a href="#selection">Selection</a> - <a href="#replacement">Replacement</a>
- <a href="#general">General Replacement</a> - <a href="#popular">Popular
evolution engines</a> - <a href="#tournament">Tournaments</a> - <a href="#merge">Merge</a>
- <a href="#reduce">Reduce</a> - <a href="#howmany">HowMany</a> - <a href="#SAD">SurviveAndDie</a>
<br>
<hr WIDTH="100%">
<br><b><font color="#CC0000">General: </font></b><a href="eoTopDown.html">Algorithm-Based</a>
- <a href="eoBottomUp.html">Component-Based</a> - <a href="eoProgramming.html">Programming
hints</a> - <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/index.html">EO
documentation</a></font></font></b>
<hr WIDTH="100%">
<address>
<a href="mailto:Marc.Schoenauer@inria.fr">Marc Schoenauer</a></address>

<br><!-- Created: Mon Oct 30 07:27:13 CET 2000 --><!-- hhmts start -->Last
modified: Tue. Jan. 9 2001&nbsp;<!-- hhmts end -->
</body>
</html>

<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; Linux 2.4.7-10 i686) [Netscape]">
   <title>Variation Operators</title>
</head>
<body text="#000000" link="#0000EF" vlink="#51188E" alink="#FF0000" background="beige009.jpg">
<b><font color="#FF0000">General</font></b>: <a href="eoTopDown.html">Algorithm-Based</a>
- <a href="eoBottomUp.html">Component-Based</a> - <a href="eoProgramming.html">Programming
hints</a> - <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/index.html">EO
documentation</a></font></font></b>
<br>
<hr WIDTH="100%">
<br><b><font color="#FF0000">Local</font></b>: <a href="#introduction">Introduction</a>
- <a href="#crossover">Crossover</a> - <a href="#mutation">Mutation</a>
- <a href="#proportional_simple">Combinations</a> - <a href="#general">General
Operators</a> - <a href="#populators">Populators</a> - <a href="#general_combination">General
combinations</a>- <a href="#advanced_general">Advanced operators</a>
<br>
<hr WIDTH="100%">
<center>
<h1>
<b><font color="#CC0000">Variation Operators</font></b></h1></center>
<a NAME="introduction"></a><b><font color="#000099"><font size=+2>Variation
Operators</font></font></b>
<br>Variation operators modify the gnotype of individuals, or, equivalently,
move them in the search space. In Evolutionary Algorithms, varitaion operators
are almost always <b><font color="#FF6600">stochastic</font></b>, i.e.
they are based on random numbers, or equivalently, perform random modifications
of their arguments. Variation operators are classified depending on the
number of arguments they use and/or modify.
<ul>
<li>
Variation operators involving <b><font color="#FF6600">two individuals</font></b>
are called <a href="#crossover">crossover operators</a>. They can either
modify one of the parents according to the material of the other parent,
or modify both parents. In EO, the former are called Binary operators and
the latter Quadratic operators.</li>

<li>
Variation operators involving <b><font color="#FF6600">one single individual</font></b>
are called <a href="#mutation">mutation operators.</a></li>

<li>
Straightforward extensions of these simple operators allow to combine them:
in
<a href="#proportional_simple">proportional combinations</a>, one operator
is chosen among a given set of operators of same arity according to some
weights.</li>

<li>
In EO you can also define and use variation operators that generate any
number of offspring from any number of parents (sometimes termed <b><font color="#FF6600">orgy</font></b>
operators). They are called <a href="#general">general operators</a>.</li>

<li>
However, the interface of such operators was designed for their use inside
<a href="#general_combination">general
combinations</a>: you can use <b><font color="#FF6600">proportional combination</font></b>,
in which one operator is chosen among a given set of operators of same
arity according to some weights, as for simple operators except that operators
of different arities can be mixed, but you can also use <b><font color="#FF6600">sequential
combinations</font></b>, where different operators&nbsp; are applied in
turn with given probability. But you can also embed any of such combinations
at any depth.</li>

<li>
The price to pay for that is that you must use an instermediate class to
access the individuals, the <a href="#populators">eoPopulator</a> class.</li>

<li>
Thanks to that class, it also become easy to design <a href="#advanced_general">advanced
operators</a>, such as crossover operators where the mate is chosen according
to <b><font color="#FF6600">sexual preference</font></b> rather than fitness-based
preferences.</li>
</ul>
<b><font color="#FF0000">Implementation</font></b>
<p>The basic idea of EO variation operators is that they operate on genotypes
only. Hence there should be generally no reference to anything related
to the fitness within a variation operator. However, whenever the genotype
of an individual has been modified, it will be necessary to recompute its
fitness before any selection process. This is why <b><font color="#FF6600">all
variation operator return</font></b> a bool that indicates whether or not
the genotype argument has been modified or not.
<p><b><font color="#FF0000">EO classes for variation operators</font></b>:
<ul>
<li>
<b><font color="#FF0000">Base classes</font></b>: all variation operators
in EO derive from the base (pure abstract) class <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_op.html">eoOp</a></font></font></b>
(as usual, click to see the inheritance diagram).&nbsp; Four (also abstract)
classes derive from <b><font color="#CC33CC">eoOp</font></b>, namely <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_mon_op.html">eoMonOp</a></font></font></b>
(for <a href="#mutation">mutations</a>), <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_bin_op.html">eoBinOp</a></font></font></b>
and <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_quad_op.html">eoQuadOp</a></font></font></b>
(for <a href="#crossover">crossover</a>) and <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_gen_op.html">eoGenOp</a></font></font></b>
for <a href="#general">all other operators</a>.</li>

<li>
<b><font color="#FF0000">Combined classes</font></b>: those classes combine
variation operators, and are variation operators by themselves: the simple
variation operators can be combined into the corresponding <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_prop_combined_mon_op.html">eoProportionalCombinedMonOp</a></font></font></b>,
<b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_prop_combined_bin_op.html">eoProportionalCombinedBinOp</a></font></font></b>
and <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_pro_combined_quad_op.html">eoProportionalCombinedQuadOp</a></font></font></b>.
The general operators <b><font color="#CC33CC">eoGenOp</font></b> can be
combined into some <b><font face="Arial,Helvetica"><font color="#000000"><font size=+1><a href="../../doc/html/classeo_op_container.html">eoOpContainer</a></font></font></font></b>,
abstract class with two implementations, <b><font face="Arial,Helvetica"><font color="#000000"><font size=+1><a href="../../doc/html/classeo_proportional_op.html">eoProportionalOp</a></font></font></font></b>
and <b><font face="Arial,Helvetica"><font color="#000000"><font size=+1><a href="../../doc/html/classeo_sequential_op.html">eoSequentialOp</a></font></font></font></b></li>

<li>
<b><font color="#FF0000">Related classes</font></b>: General operators
of class <b><font color="#CC33CC">eoGenOp</font></b> can only be used through
the <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_populator.html">eoPopulator</a></font></font></b>
class.</li>
</ul>

<hr WIDTH="100%"><a NAME="crossover"></a><b><font size=+1><font color="#000099">Simple
operators: </font><font color="#FF0000">Crossover</font></font></b>
<p>The characteristic of crossover operators is that they involve two parents.
However, there are crossover operators that generate two parents, and some
that generate one parent only, and both types are available in EO. The
former type (2 --> 2) is termed quadratic crossover operator, and is implemanted
in the <b><font color="#CC33CC">eoQuadOp</font></b> class; the latter type
(2 --> 1) is termed binary operator and is implemanted in class <b><font color="#CC33CC">eoBinOp</font></b>.
Both classes are, as usual, templatized by the type of individual they
can handle (see documentation for <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_bin_op.html">eoBinOp</a></font></font></b>
and <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_quad_op.html">eoQuadOp</a></font></font></b>).
<p><b><font color="#FF0000">Note:</font></b> Whereas it is straightforward
to create a binary crossover operator from a quadratic one (by discarding
the changes on the second parent), the reverse might prove impossible (imagine
a binary crossover that simply merges the parents material: there is no
way to generate two new parents from that!).
<p><b><font color="#FF0000">Interfaces</font></b>:
<br>The general approach in EO about simple variation operators is to perform
<b><font color="#FF6600">in-place
modifications</font></b>, i.e. modifying the arguments rather than generating
new (modified) individuals. This results in the following interfaces for
the functor objects eoBinOp and eoQuadOp:
<p><b><tt><font color="#993300">bool operator()(EOT &amp; , const EOT &amp;)&nbsp;</font></tt></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for eoBinOp (note the const)
<br><b><tt><font color="#993300">bool operator()(EOT &amp; , EOT &amp;
)&nbsp;</font></tt></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for eoQuadOp
<p>which you could have guessed from the inheritance diagrams up to the
eoBF abstract class. You can also guess that only the first argument will
be modified by an oeBin object, while both arguments will be modified by
an eoQuad object.
<p><b><font color="#FF0000">Using crossover operators</font></b>:
<br>Directly applying crossover operators is straightforward from the interface
above:
<br><tt><font color="#993300"><b>eoBinOpDerivedClass&lt;Indi> myBinOp(parameters);
</b>//&nbsp;
use constructor to pass</font></tt>
<br><tt><font color="#993300"><b>eoQuadOpDerivedClass&lt;Indi> myQuadOp(parameters);
</b>//&nbsp;
any useful argument</font></tt>
<br><tt><font color="#993300"><b>Indi eo1= ..., eo2= ...;&nbsp;&nbsp; </b>//
the candidates to crossover</font></tt>
<br><b><tt><font color="#993300">if (myBinOp(eo1, eo2))</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp;&nbsp; { ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</b>// eo1 has been modified, <b>not</b> eo2</font></tt>
<br><b><tt><font color="#993300">&nbsp;&nbsp; }</font></tt></b>
<br><tt><font color="#993300"><b>else ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</b>// none has been modified</font></tt>
<br><b><tt><font color="#993300">if (myQuadOp(eo1, eo2))</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp;&nbsp; { ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</b>// both eo1 and eo2 have been modified</font></tt>
<br><b><tt><font color="#993300">&nbsp;&nbsp; }</font></tt></b>
<br><tt><font color="#993300"><b>else ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</b>// none has been modified</font></tt>
<p>However, you will hardly have to actually apply operators to individuals,
as operators are used within other classes, and are applied systematically
to whole sets of individuals (e.g. that have already been selected, in
standard generation-based evolutionary algorithms).
<br>Hence the way to use such operators will more likely ressemble <a href="FirstRealGA.html#operators">this</a>
if you are using for instance an SGA. See also the different ways that
are described below, encapsulating the operators into combined operators
objects.
<p><a NAME="writing_crossover"></a><b><font color="#FF0000">Writing a crossover
operator:</font></b>
<br>There are three things to modify in the template class definitions
provided in the Templates directory for both <a href="../Templates/binCrossover.tmpl">binary
crossover</a> and <a href="../Templates/quadCrossover.tmpl">quadratic crossovers</a>
(apart from the name of the class you are creating!)
<ul>
<li>
The <font color="#FF6600">constructor</font>, where you pass to the object
any useful parameter (see the private data at end of class definition).</li>

<li>
The <font color="#FF6600">operator()</font> method, which performs the
actual crossover.</li>

<li>
The <font color="#FF6600">return value</font>, that should be <b><tt><font color="#993300">true</font></tt></b>
as soon as at least one genotype has actually been modified. Otherwise,
the <a href="eoEval.html#lazy">lazy fitness evaluation procedure</a> in
EO might not know it should compute the fitness again and will keep the
old value.</li>
</ul>

<hr WIDTH="100%"><a NAME="mutation"></a><b><font color="#000099"><font size=+1>Simple
operators: </font></font><font color="#FF0000"><font size=+2>Mutation</font></font></b>
<br>Mutation operators modify one single individual. The corresponding
EO class is called <b><font color="#CC33CC">eoMonOp</font></b>. and it
si as usual templatized by the type of individual it can handle (see documentation
for <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_mon_op.html">eoMonOp</a></font></font></b>).
<p><b><font color="#FF0000">Interfaces</font></b>:
<br>The general approach in EO about simple variation operators is to perform
<b><font color="#FF6600">in-place
modifications</font></b>, i.e. modifying the arguments rather than generating
new (modified) individuals. This results in the following interface for
the functor objects eoMonOp:
<p><b><tt><font color="#993300">bool operator()(EOT &amp; )</font></tt></b>
<p>which you could have guessed from the inheritance diagrams up to the
eoUF abstract class.
<p><b><font color="#FF0000">Using mutation operators</font></b>:
<br>Directly applying mutation operators is straightforward from the interface
above:
<br><tt><font color="#993300"><b>eoMonOpDerivedClass&lt;Indi> myMutation(parameters);</b>
//pass parameters in constructor</font></tt>
<br><tt><font color="#993300"><b>Indi eo = ...;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/</b>/ eo is candidate to mutation</font></tt>
<br><b><tt><font color="#993300">if (myMutation(eo))</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp;&nbsp; { ...&nbsp;&nbsp;&nbsp; </b>//
eo has been modified</font></tt>
<br><b><tt><font color="#993300">&nbsp;&nbsp; }</font></tt></b>
<br><tt><font color="#993300"><b>else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>//
eo has not been modified</font></tt>
<p>However, you will hardly have to actually apply operators to individuals,
as operators are used within other classes, and are applied systematically
to whole sets of individuals (e.g. that have already been selected, in
standard generational evolutionary algorithms).
<br>Hence the way to use such operators will more likely ressemble <a href="FirstRealGA.html#operators">this</a>
if you are using for instance an SGA. See also the different ways that
are described below, encapsulating the operators into combined operators
objects.
<p><a NAME="writing_mutation"></a><b><font color="#FF0000">Writing a mutation
operator:</font></b>
<br>There are only two things to modify in the <a href="../Templates/mutation.tmpl">template
class definitions</a> provided in the Templates directory (apart from the
name of the class you are creating!)
<ul>
<li>
The <font color="#FF6600">constructor</font>, where you pass to the object
any useful parameter (see the private data at end of class definition).</li>

<li>
The <font color="#FF6600">operator()</font> method, which performs the
actual crossover.</li>

<li>
The <font color="#FF6600">return value</font>, that should be <b><tt><font color="#993300">true</font></tt></b>
as soon as the genotype has actually been modified.&nbsp; Otherwise, the
<a href="eoEval.html#lazy">lazy
fitness evaluation procedure</a> in EO might not know it should compute
the fitness again and will keep the old value.</li>
</ul>

<hr WIDTH="100%"><a NAME="proportional_simple"></a><b><font size=+1><font color="#000099">Combining
simple operators: </font><font color="#FF0000">proportional combinations</font></font></b>
<p>The best thing to do is to go to the <a href="eoLesson2.html#combined_operators">Lesson2</a>
of the tutorial, where everything is explained. You will find out how you
can use
<br>several mutations (respectiveley quadratic crossovers) as a single
operator: every time the operator is called, one of the available operators
is chosen by some roulette wheel selection using realtive weights.
<p>
<hr WIDTH="100%"><a NAME="general"></a><b><font color="#000099"><font size=+2>General
Operators</font></font></b>
<p>General operators in EO are variation operators that are neither simple
mutations nor simple crossovers. They can involve any number of parents,
and create any number of offspring. Moreover, they can make use of different
ways to get the parents they will involve, e.g. they can use a different
selector for each of the parents they need to select.
<p>The corresponding EO class is called <b><font color="#CC33CC">eoGenOp</font></b>.
and it is as usual templatized by the type of individual it can handle
(see documentation for <b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/classeo_mon_op.html">eoGenOp</a></font></font></b>
:-)
<p><a NAME="interface"></a><b><font color="#FF0000">Interface</font></b>:
<br>All the work a general operator is done within the <b><tt><font color="#993300">apply()</font></tt></b>
method. WHy not in the usual operator() method? Because some memory management
are needed, that are performed in the base class itself - which then calls
the virtual <b><tt><font color="#993300">apply()</font></tt></b> method.
The interface for a <b><font color="#CC33CC">eoGenOp</font></b> thus is
not deducible from its inheritance diagram, and actually is
<p><b><tt><font color="#993300">&nbsp;&nbsp;&nbsp; void apply(eoPopulator&lt;EOT>&amp;
_plop)</font></tt></b>
<p><font color="#000000">As you can see,the interface for </font><b><font color="#CC33CC">eoGenOp</font></b><font color="#000000">
is based on that of another class, called </font><b><font color="#999900">eoPopulator</font><font color="#CC33CC">.
</font></b>An
<b><font color="#999900">eoPopulator</font></b>
is a <b><font color="#FF6600">population</font></b>, but also behaves like
an <b><font color="#FF6600">iterator</font></b> over a population (hence
the name, <b><font color="#FF6600">Popul</font></b>ation-Iter<b><font color="#FF6600">ator</font></b>).&nbsp;
However, please note that you should probably never use an eoGenOp alone,
but rather through objects of type <a href="#general_combination">eoOpContainer</a>.
<p>This results in the following general interface for an <b><font color="#CC33CC">eoGenOp</font></b>:
It receives as argument an <b><font color="#999900">eoPopulator</font></b>,
gets the individuals it needs using the <b><tt><font color="#993300">operator*</font></tt></b>,
and must handle the positinning of the&nbsp; using the <b><tt><font color="#993300">++operator</font></tt></b>
method (<b><font color="#FF6600">Warning</font></b>: the <b><tt><font color="#993300">operator++</font></tt></b>
method is not defined, as recommended by many good-programming-style books).
<p><a NAME="apply"></a><b><tt><font color="#993300">bool apply()(</font><font color="#999900">eoPopulator</font><font color="#993300">&amp;
_pop)</font></tt></b>
<br><b><tt><font color="#993300">{</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp;&nbsp; EOT&amp; parent1 = *_pop;
</b>//
select the first parent</font></tt>
<br><tt><font color="#993300"><b>&nbsp;&nbsp; ++_plop;&nbsp;&nbsp; </b>//
advance once for each selected parents</font></tt>
<br><b><tt><font color="#993300">&nbsp;&nbsp; ...</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp;&nbsp; EOT&amp; parentN = *_pop;
</b>//
select the last parent</font></tt>
<br><tt><font color="#993300"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>//
don't advance after the last one: _plop always</font></tt>
<br><tt><font color="#993300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// points to the last that has already been treated</font></tt>
<p><tt><font color="#993300">// do whatever the operator is supposed to
do</font></tt>
<br><b><tt><font color="#993300">}</font></tt></b>
<p><b><font color="#FF6600">Warning</font></b>: as said above, an eoPopulator
should always point to the last individual that has already been treated.
This is because it is intended to be used within a loop that looks like
(see e.g. <b><tt><a href="../../doc/html/classeo_general_breeder.html">eoBreeder</a></tt></b>
class):
<p><tt><font color="#993300"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eoSelectivePopulator&lt;EOT>
popit(_parents, _offspring, select);</b>&nbsp;&nbsp;&nbsp; // eoSelect
is an eoSelectOne</font></tt>
<br><b><tt><font color="#993300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (_offspring.size()
&lt; target)</font></tt></b>
<br><b><tt><font color="#993300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</font></tt></b>
<br><b><tt><font color="#993300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
op(popit);</font></tt></b>
<br><b><tt><font color="#993300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++it;</font></tt></b>
<br><b><tt><font color="#993300">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font></tt></b>
<p><b><font color="#FF6600">What happens next?</font></b> Well, it all
depends on how many parents and how many offspring your general op needs:
<ul>
<li>
If the number of generated offspring is <font color="#FF6600">equal</font>
to the number of parents, the operator simply needs to modify them (they
are passed by reference, no useless copy takes place).</li>

<li>
If the operator produces <font color="#FF6600">more offspring than there
were parents</font>, it needs to insert them into the list using the <b><tt><font color="#993300">insert</font></tt></b>
method of the class <b><font color="#999900">eoPopulator</font></b> as
in the following:</li>

<br>&nbsp;
<p>&nbsp;
<p><b><tt><font color="#993300">void apply()(</font><font color="#999900">eoPopulator</font><font color="#993300">&amp;
_pop)</font></tt></b>
<br><b><tt><font color="#993300">{</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp; </b>// get the necessary number
of parents (see <a href="#apply">above</a>)</font></tt>
<br><tt><font color="#993300">&nbsp; ...</font></tt>
<br><tt><font color="#993300">&nbsp; // Now create any supplementary offspring</font></tt>
<br><b><tt><font color="#993300">&nbsp; EOT ofs1 = create_individual(...);</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; ...</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; EOT ofsK = create_individual(...);</font></tt></b>
<br><tt><font color="#993300">&nbsp; // advance and inserts offspring in
_pop after parentN</font></tt>
<br><b><tt><font color="#993300">&nbsp; ++_pop;</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; _pop.insert(ofs1);</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; ...</font></tt></b>
<p><tt><font color="#993300"><b>&nbsp; </b>// invalidate the parents that
have been modified</font></tt>
<br><b><tt><font color="#993300">&nbsp; parent1.invalidate();</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; ...</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; parentN.invalidate();</font></tt></b>
<br><tt><font color="#993300"><b>}</b>&nbsp;&nbsp; // over</font></tt>
<p>Of course the size of the resulting population will grow - and you should
have a replacement procedure that takes care of that.
<br>&nbsp;
<li>
The case where <font color="#FF6600">more parents are needed than offspring
will be created</font> is a little more delicate: think about <b><font color="#CC33CC">eoBinOp</font></b>,
and try to imagine the reasons why no crossover of that class are used
in the first lessons of the tutorial, within the SGA framework.</li>

<br>There are two possibilities:
<ul>
<li>
If you think "generational", the first idea is to get the parents from
outside the curent list, so the total number of (intermediate) offspring
is always equal to the initial population size. By chance, the <b><font color="#999900">eoPopulator</font></b>has
a handle on the initial population that was used to start the process,
and you can access it from inside the GenOp method. For instance</li>

<br>&nbsp;
<p>&nbsp;
<p><b><tt><font color="#993300">void apply()(</font><font color="#999900">eoPopulator</font><font color="#993300">&amp;
_pop)</font></tt></b>
<br><b><tt><font color="#993300">{</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp; </b>// get as many parents as you
will have offspring (see <a href="#apply">above</a>)</font></tt>
<br><tt><font color="#993300">&nbsp; ...</font></tt>
<br><tt><font color="#993300"><b>&nbsp; // </b>get extra parents - use
private selector</font></tt>
<br><b><tt><font color="#993300">&nbsp; const EOT&amp; parentN+1 = </font><font color="#009900">select</font><font color="#993300">(_pop.source());</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; ...</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; const EOT&amp; parentM = </font><font color="#009900">select</font><font color="#993300">(_pop.source());</font></tt></b>
<br><tt><font color="#993300">&nbsp; // do whatever needs to be done</font></tt>
<br><tt><font color="#993300">&nbsp; ...</font></tt>
<br><tt><font color="#993300">&nbsp; // and of course invalidate fitnesses
of remaining modified parents</font></tt>
<br><tt><font color="#993300">&nbsp; <b>parent1.invalidate();</b></font></tt>
<br><b><tt><font color="#993300">&nbsp; ...</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; parentN.invalidate();</font></tt></b>
<br><b><tt><font color="#993300">}</font></tt></b>
<br>where select is any selector you like. <font color="#FF6600">Note the
const:</font> you are not allowed to modify an element of the original
population (but you could of course have copied it!). As usual, the <b><tt><font color="#009900">select</font></tt></b>
selector was passed to the operator at construct time. This typically allows
one to use a different selector for one parent and the others, as demonstrated
<a href="#advanced_general">here</a>.
<br>&nbsp;
<li>
If you don't care about the size of the offspring population (that is,
if that size os controlled elsewhere, e.g. in some external loop), you
can use the inbedded select method of the class <b><font color="#999900">eoPopulator</font></b>.
For instance</li>

<br>&nbsp;
<p>&nbsp;
<p><b><tt><font color="#993300">void apply()(</font><font color="#999900">eoPopulator</font><font color="#993300">&amp;
_pop)</font></tt></b>
<br><b><tt><font color="#993300">{</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp; </b>// get as many parents as you
will have offspring (see <a href="#apply">above</a>)</font></tt>
<br><tt><font color="#993300">&nbsp; ...</font></tt>
<br><tt><font color="#993300"><b>&nbsp; </b>// get extra parents - use
populator selector</font></tt>
<br><b><tt><font color="#993300">&nbsp; const EOT&amp; parentN+1 = _pop.</font><font color="#009900">select</font><font color="#993300">();</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; ...</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; const EOT&amp; parentM = _pop.</font><font color="#009900">select</font><font color="#993300">();</font></tt></b>
<br><tt><font color="#993300">&nbsp; // do whatever needs to be done</font></tt>
<br><tt><font color="#993300">&nbsp; ...</font></tt>
<br><tt><font color="#993300">&nbsp; // and of course invalidate fitnesses
of remaining modified parents</font></tt>
<br><tt><font color="#993300">&nbsp; <b>parent1.invalidate();</b></font></tt>
<br><b><tt><font color="#993300">&nbsp; ...</font></tt></b>
<br><b><tt><font color="#993300">&nbsp; parentN.invalidate();</font></tt></b>
<br><tt><font color="#993300">}</font></tt></ul>
</ul>
<b><font color="#FF6600">Warning</font></b>: if you use operators that
have different number of parents than offspring, you are deviating from
the simple generational approach. Be careful to have the proper replacement
procedure to take care of the population size: in most instances of algorithms
that come within EO, this is enforced (an exception is thrown if population
size varies from one genertaion to the other) but this might not be true
for all forthcoming EO algorithms.
<p><b><font color="#FF0000">Using general operators</font></b>:
<br>Directly applying general operators to given individuals is impossible
in EO, due to its <a href="#interface">interface</a>. You need the help
of an individual dispenser of class <b><font color="#999900">eoPopulator</font></b>.
But anyway general operators were thought to be used putely in <b><tt><font color="#CC33CC">eoOpContainer</font></tt></b>,
as described <a href="#general_combination">below</a>.
<p><a NAME="writing_mutation"></a><b><font color="#FF0000">Writing a general
operator:</font></b>
<br>There are many things to do to write a general operator - but the Templates
directory contains some sample tempaltes files to help you. It all depends
on whether you want more or less offspring than parents, and whetehr you
want the same selector for every parent or more specialized selectors.
<ul>
<li>
It you want <font color="#FF6600">more (or as many) </font>offspring than
parents, you should use the <a href="../Templates/moreOffspringGenOp.tmpl">moreOffspringGenOp.tmpl</a>
template - if you want to use the same selector for all parents, the one
embedded in the argument <b><font color="#999900">eoPopulator</font></b>.
Otherwise, you'll have to write your own operator based on an external
selector, as described in <a href="../Templates/lessOffspringExternalSelectorGenOp.tmpl">lessOffspringExternalSelectorGenOp.tmpl</a>.</li>

<li>
If you decide to have more parents than offspring, you can decide either
to get the extra parents using the <b><font color="#999900">eoPopulator</font></b>&nbsp;
own selector (see <a href="../Templates/lessOffspringSameSelectorGenOp.tmpl">lessOffspringSameSelectorGenOp.tmpl</a>,
or to use an external selector (passed at construct-time) as described
in <a href="../Templates/lessOffspringExternalSelectorGenOp.tmpl">lessOffspringExternalSelectorGenOp.tmpl</a>.</li>

<li>
Now you can modify the <font color="#FF6600">constructor</font>, where
you pass to the object any useful parameter (see private data at end of
class definition). In case you need an external selector, you have to choose
it (or write it!) - it should be an <a href="eoEngine.html#selection">eoSelectOne</a>
object.</li>

<li>
Finally, write the core of the operator in method <font color="#FF6600">apply()</font>.
Remember you must use the argument <b><font color="#999900">eoPopulator
</font></b>to
access the members of the population in turn (method
<b><tt><font color="#993300">operator*</font></tt></b>),
you may use the initial population (method <b><tt><font color="#993300">source()</font></tt></b>),
as well as the <b><tt><font color="#993300">insert</font></tt></b> methods.</li>
</ul>

<ul><b><font color="#FF6600">Warning</font></b>: in general operators,
you must not forget to <b><font color="#FF6600">invalidate</font></b> the
fitness of any individual that has actually been modified. this implicitely
implies that general operators can only be applied to EO object (i.e. objects
with a fitness), and not to any type of structure.
<br>It you don't invalidate the individual, the <a href="eoEval.html#lazy">lazy
fitness evaluation procedure</a> in EO will not know it should compute
the fitness again and will keep the old obsolete value.</ul>

<hr WIDTH="100%"><a NAME="populators"></a><b><font color="#000099"><font size=+2>The
populators:</font></font></b>
<br>As has been said above, an
<b><font color="#999900">eoPopulator</font></b>
mainly behaves like an <b><font color="#FF6600">iterator</font></b> over
a population (hence the name, <b><font color="#FF6600">Popul</font></b>ation-Iter<b><font color="#FF6600">ator</font></b>).
<p><a NAME="populator_interface"></a>The <b><font color="#FF6600">basic
interface</font></b> of an <b><font color="#999900">eoPopulator</font></b>
(see also <a href="../../doc/html/classeo_gen_op.html">the documentation</a>,
of course) is the following:
<ul>
<li>
Individuals are accessed through the <b><tt><font color="#993300">operator*</font></tt></b>;</li>

<li>
Basic iterator operations are available, like (pre)incrementation through
<b><tt><font color="#993300">operator++</font></tt></b>,
position management through <b><tt><font color="#993300">seekp</font></tt></b>
(returns the current position) and <b><tt><font color="#993300">tellp</font></tt></b>
(go to a given position);</li>

<li>
Individuals can also be <b><font color="#993300">insert</font></b>ed at
current position using the corresponding methods;</li>

<li>
last but not least, as the individuals are returned by reference, it is
mandatory to ensure that they will not be moved around later: the memory
management&nbsp; routine <b><tt><font color="#993300">reserve</font></tt></b>
is called whenever there is a chance to add some individuals in the population
- i.e. in the eoGenOp base class operator() method.</li>
</ul>
Moreover, a public method termed <b><tt><font color="#993300">select</font></tt></b>,&nbsp;
is used inside the object to get new parents for the following <b><tt><font color="#993300">operator*</font></tt></b>,
and its implementation distinguishes two types of <b><font color="#999900">eoPopulator</font></b>:
<ul>
<li>
The <b><font color="#999900">eoSeqPopulator</font></b> gets new parents
from its source (the initial population). When the source is exhausted,
an exception if thrown. The idea of such pooulator is to start from a population
of already selected individuals.</li>

<br>The programmer should hence be very careful that the number of available
parents matches the requirements of the operators when using an <b><font color="#999900">eoSeqPopulator</font></b>
object.
<li>
The <b><font color="#999900">eoSelectivePopulator</font></b> , on the opposite,
always gets new parents using its private <b><font color="#009900">eoSelectOne</font></b>
object (passed at construct time). Hence it can handle any number of parents
at will. The idea of such populator is to handle the whole <b><font color="#FF6600">breeding</font></b>
process, i.e. selection and variation operators.</li>
</ul>
An immediate consequence is that if you are not sure of the number of&nbsp;
parents you will need in some operators (e.g. because of some stochastic
proportional selection ebtween operators that don't need the same number
of parents, then you <b><font color="#FF6600">must</font></b> use an <b><font color="#CC33CC">eoSelectivePopulator</font></b>
to apply the variation operators to the population, and thus get exactly
the number of offspring you want.
<p><b><font color="#FF0000">Example</font></b>: An <b><font color="#CC33CC">eoSelectivePopulator</font></b>
is the main ingredient of the <b><tt><font color="#FF6666">eoGeneralBreeder
</font></tt></b><a href="../../doc/html/eo_general_breeder_8h-source.html#l00061">operator()
method</a> - a class that creates a population of offspring from the parents
applying an eoGenOp (usually an eoOpContainer) to all selected parents
in turn.
<br>
<hr WIDTH="100%"><a NAME="general_combination"></a><b><font color="#000099"><font size=+2>General
Operator Containers:</font></font></b>
<br>General operators in EO are meant to be used withing eoOpContainer
objects, that allow to combine them in a hierarchical and flexible way.
There are two ways to do that: the <b><font color="#FF6600">proportional
combination</font></b>, similar to what has been described for simple operators
<a href="#proportional_simple">above</a>,
and the <b><font color="#FF6600">sequential combination</font></b>, which
amounts to apply all operators in turn to a bunch of individuals, each
operator being applied with a specific probability.
<p><a NAME="prop_container"></a><b><font color="#FF0000">Proportional combinations</font></b>
<br>When called upon a population (through an <b><font color="#999900">eoPopulator</font></b>
object), an <b><font color="#CC33CC">eoProportionalOpContainer</font></b>
enters the following loop:
<p>while there are individuals left in the list
<ul>
<li>
choose one of the included operators according to their relative rates
(by some roulette wheel random choice)</li>

<li>
applies the chosen operator. The parents are dispensed to the operator
from the list on demand.</li>

<li>
What happens next exactly depends on the type of operator, but basically,
some of the parents get modified, some might get removed from the list
and some new individual might get inserted on the list.</li>

<li>
updates the list pointer (if needed) to the individual following the ones
that just have been modified/inserted/deleted.</li>
</ul>
<a NAME="seqential_container"></a><b><font color="#FF0000">Sequential combinations</font></b>
<br>When it is called upon a list of pending candidates, an
<b><font color="#CC33CC">eoSequentialOpContainer</font></b>
enters the following loop:
<p>mark the current position
<br>for all operators it contains,
<ul>
<li>
go to marked position</li>

<li>
until <a href="#container_and_populator">current end of population</a>
is reached do</li>

<ul>
<li>
flip a coin according to the operator rate.</li>

<ul>
<li>
If true, apply the operator to the parents. The current parents can be
modified, or some can be deleted from the list, or some offspring can be
inserted in the list.</li>

<li>
If false, move the pointer over the required number of parents (i.e. don't
modify thoses parents)</li>
</ul>

<li>
Next pending parent</li>
</ul>

<li>
Next operator</li>
</ul>
<b><font color="#FF6600">Warning</font></b>: the way <b><tt><font color="#993300">rate</font></tt></b>
will be used is highly dependent on the type of <b><font color="#CC33CC">eoOpContainer</font></b>
your are creating there:
<ul>
<li>
The rates for <b><font color="#CC33CC">eoProportionalOpContainer</font></b>
will be used in a roulette wheel choice among all operators. They can take
any value, the only important thing is their <b><font color="#FF6600">relative
values</font></b>.</li>

<li>
The "rates" for <b><font color="#CC33CC">eoSequentialOpContainer </font></b>actually
are <b><font color="#FF6600">probabilities</font></b>, i.e. they will be
used in a coin-flipping to determine whether that particuler operator will
be applied to the next candidates at hand. They should be <b><font color="#FF6600">in
[0,1]</font></b> (no error will happen if they are not, but the operator
will be applied systematically - this is equivalent of a rate equal to
1).</li>
</ul>
<font color="#FF6600">Remark:</font>The eoSGATransform presented in <a href="eoLesson2.html#transform">Lesson2</a>
can be viewed as a particular type of <b><font color="#CC33CC">eoSequentialOpContainer</font></b>.
It was not coded that way in order to provide a gradual introduction to
all concepts.
<br><font color="#FF6600">Exercise</font>: write the code to perform an
eoSGA using the eoOpContainer constructs.
<p><b><font color="#FF0000">Adding operators to a container:</font></b>
<br>The way to add an operator to an <b><font color="#CC33CC">eoOpContainer</font></b>
is the method
<b><tt><font color="#993300">add</font></tt></b>. It is similar
to all other <b><tt><font color="#993300">add</font></tt></b> methods in
other Combined things in eo (as the simple eoProportionalCombinedXXXop
described above, but also the eoCombinedContinue class or the eoCheckPoint
class).
<br>The syntax is straightforward, and it works with any of the operator
classes <b><font color="#CC33CC">eoXXXOp</font></b>, where XXX stands for
<b><font color="#CC33CC">Mon,
Bin, Quad </font></b><font color="#000000">or</font><b><font color="#CC33CC">
Gen</font></b>:
<p><b><tt><font color="#993300">someOperatorType&lt;Indi> myOperator;</font></tt></b>
<br><b><tt><font color="#993300">eoYYYOpContainer&lt;Indi> myOpContainer;</font></tt></b>
<br><tt><font color="#993300"><b>myOpContainer.add(myOperator, rate); </b>//
rate: double whose <b>meaning depends on YYY</b></font></tt>
<p>where YYY can be one of Proportional and Sequential. Note that before
being added to the container, all simple operators are wrapped into the
corresponding eoGenOp (see e.g. how an <b><font color="#CC33CC">eoMonOp</font></b><a href="../../doc/html/eo_gen_op_8h-source.html#l00084">is
wrapped</a> into an <b><font color="#CC33CC">eoMonGenOp</font></b>- or
how <a href="../../doc/html/eo_gen_op_8h-source.html#l00169">any operator
is handled</a> by calling the appropriate wrapper). In particular, the
wrapper ensures that <b><font color="#FF6600">individuals who have been
modified are invalidated</font></b>.
<p><a NAME="container_and_populator"></a><b><font color="#FF0000">Containers,
Selectors and Populators</font></b>
<br>The way the <b><font color="#CC33CC">eoOpContainer</font></b> are applied
on a population using an <b><font color="#999900">eoPopulator</font></b>
object. But, whereas the behavior of <b><font color="#CC33CC"><a href="#prop_container">eoProportionalOpContainer</a></font></b>
does not depend on the type of <b><font color="#999900">eoPopulator</font></b>,(one
operator is chosen by roulette_wheel, and applied once before control is
given back to the caller), the main loop in method <b><tt><font color="#993300">operator()
</font></tt></b>of
class <b><font color="#CC33CC"><a href="#seqential_container">eoSequentialOpContainer</a></font></b>
iterates <b><tt><font color="#993300">while (!_pop.exhausted())</font></tt></b>
which is interpreted differently depending on the <a href="#populators">type
of <b><font color="#CC33CC">eoPopulator</font></b></a>:
<ul>
<li>
if the argument is an <b><font color="#999900">eoSelectivePopulator</font></b>,
the default position of the eoPopulator, considered as a population iterator,
is at end of population. Individuals are added upon demand of an operator,
and in most cases all operators are applied once. This also depends, however,
on the arities of all operators:</li>

<ul>
<li>
Consider an <b><font color="#CC33CC">eoSequentialOpContainer</font></b>
containing an eoQuadOp and an eoMonOp. The eoQuadOp first asks for two
parents and modifies them. The eoMonOp is then called starting from the
forst of thoses two modified individuals, and is hence applied twice, once
on each parent.</li>

<li>
But consider now an <b><font color="#CC33CC">eoSequentialOpContainer</font></b>
containing an <b><font color="#CC33CC">eoGenOp</font></b> that takes one
parent and generates three offspring, followed by an <b><font color="#CC33CC">eoQuadOp</font></b>.
The <b><font color="#CC33CC">eoGenOp</font></b> will call the selector
to get the parent its need and will modify it and put 2 additional offspring
at end of the population. The <b><font color="#CC33CC">eoQuadOp</font></b>
will then be called on the first of the three outputs of the <b><font color="#CC33CC">eoGenOp</font></b>,
and hence will act upon the frist two of them. But at that point, the populator
iterator will point to the third of the individuals resulting from the
<b><font color="#CC33CC">eoGenOp</font></b>,
and the test <b><tt><font color="#993300">_pop.exhausted()</font></tt></b>
will return false, so the <b><font color="#CC33CC">eoQuadOp</font></b>
will again be called. The second parent it needs will be given by a new
call to the embedded <b><font color="#009900">eoSelectOne</font></b> of
the&nbsp; and everything will go on smoothly, except that a total of 4
offspring will have been generated by application of this particular <b><font color="#CC33CC">eoSequentialOpContainer</font></b>.</li>
</ul>

<li>
if the argument is an <b><font color="#999900">eoSeqPopulator</font></b>,
the position of the iterator starts from the beginning of an existing population
(the source populations), and hence when an&nbsp; an <b><font color="#CC33CC">eoSequentialOpContainer</font></b>
is called, it goes through the whole remaining of the population (the test
<b><tt><font color="#993300">_pop.exhausted()</font></tt></b>
only returns true at end of the source population).</li>

<li>
From the above it is easy to see that passing an <b><font color="#999900">eoSeqPopulator</font></b>
to an <b><font color="#CC33CC">eoProportionalOpContainer</font></b> that
contains an <b><font color="#CC33CC">eoSequentialOpContainer</font></b>,
though not technically forbiddden, will most produce something&nbsp; totally
unpredictable, and hence should probably not be used without great care.</li>
</ul>

<hr WIDTH="100%"><a NAME="advanced_general"></a><b><font color="#000099"><font size=+2>Advanced
general operators:</font></font></b>
<p>It is sometimes useful to be able to use a selector from inside an operator
(a typical example is when you want to implement <b><font color="#FF6600">sexual
preferences</font></b>, i.e. choose a mate for a first parent according
to some characteritics of that first parent).
<br>This is made possible in EO because the general operators have a handle
on the initial population through the method <b><tt><font color="#993300">source()</font></tt></b>
of the argument eoPopulator they work on. Their <b><tt><font color="#993300">apply()</font></tt></b>
method shoudl look like
<p><b><tt><font color="#993300">void apply()(</font><font color="#999900">eoPopulator</font><font color="#993300">&amp;
_pop)</font></tt></b>
<br><b><tt><font color="#993300">{</font></tt></b>
<br><tt><font color="#993300"><b>&nbsp; EOT &amp; eo1 = *_pop; </b>// get
(select if necessary) the first guy</font></tt>
<br><b><tt><font color="#993300">&nbsp; EOT maBlonde = </font><font color="#009900">findBlonde</font><font color="#993300">(_pop.source());
</font></tt></b><tt><font color="#993300">//
select mate</font></tt>
<br><tt><font color="#993300">&nbsp; // do whatever the operator is supposed
to do, e.g</font></tt>
<br><tt><font color="#993300">&nbsp; <b>cross(eo1, maBonde);</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// cross is some embedded crossover</font></tt>
<br><tt><font color="#993300">&nbsp; <b>...</b></font></tt>
<br><tt><font color="#993300">&nbsp; // if you don't want to put maBlonde
into the offspring,</font></tt>
<br><tt><font color="#993300">&nbsp; // stop here (and use a reference
to maBlonde above). Otherwise</font></tt>
<br><tt><font color="#993300">&nbsp; <b>maBonde.invalidate();</b></font></tt>
<br><tt><font color="#993300"><b>&nbsp;++_pop;&nbsp;&nbsp;&nbsp; </b>//
advance</font></tt>
<br><tt><font color="#993300">&nbsp; <b>_pop.insert(maBlonde);</b>&nbsp;&nbsp;&nbsp;
// and insert it</font></tt>
<br><b><tt><font color="#993300">}</font></tt></b>
<p>Where does that <b><tt><font color="#009900">findBlonde</font></tt></b>
selector comes from? As usual, you have to attach it to the operator,&nbsp;
in its constructor for instance, which should give something like:
<p><b><tt><font color="#993300">sexualSelectorType&lt;Indi>&nbsp; findBlonde;</font></tt></b>
<br><b><tt><font color="#993300">sexualOperatorType&lt;Indi> yourBrainAndMyBeauty(cross,
findBlonde);</font></tt></b>
<p>
<hr WIDTH="100%"><b><font color="#FF0000">Local</font></b>: <a href="#introduction">Introduction</a>
- <a href="#crossover">Crossover</a> - <a href="#mutation">Mutation</a>
- <a href="#proportional_simple">Combinations</a> - <a href="#general">General
Operators</a> - <a href="#populators">Populators</a> - <a href="#general_combination">General
combinations</a>- <a href="#advanced_general">Advanced operators
<hr WIDTH="100%"></a><b><font color="#FF0000">General</font></b>: <a href="eoTopDown.html">Algorithm-Based</a>
- <a href="eoBottomUp.html">Component-Based</a> - <a href="eoProgramming.html">Programming
hints</a> -<b><font face="Arial,Helvetica"><font size=+1><a href="../../doc/html/index.html">EO
documentation</a></font></font></b>
<br>
<hr>
<address>
<a href="mailto:Marc.Schoenauer@inria.fr">Marc Schoenauer</a></address>

<br><!-- Created: Mon Oct 30 07:27:13 CET 2000 --><!-- hhmts start -->Last
modified: Sat. Feb. 17 2002&nbsp;<!-- hhmts end -->
<br>&nbsp;
</body>
</html>

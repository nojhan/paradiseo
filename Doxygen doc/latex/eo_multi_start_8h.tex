\hypertarget{eo_multi_start_8h}{}\doxysection{eo/src/mpi/eo\+Multi\+Start.h File Reference}
\label{eo_multi_start_8h}\index{eo/src/mpi/eoMultiStart.h@{eo/src/mpi/eoMultiStart.h}}
{\ttfamily \#include \char`\"{}../eo\char`\"{}}\newline
Include dependency graph for eo\+Multi\+Start.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{eo_multi_start_8h__incl}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_multi_start_data}{eo\+::mpi\+::\+Multi\+Start\+Data$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Data used by the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_send_task_multi_start}{eo\+::mpi\+::\+Send\+Task\+Multi\+Start$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Send task (master side) in the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_handle_response_multi_start}{eo\+::mpi\+::\+Handle\+Response\+Multi\+Start$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Handle Response (master side) in the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_process_task_multi_start}{eo\+::mpi\+::\+Process\+Task\+Multi\+Start$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Process Task (worker side) in the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_is_finished_multi_start}{eo\+::mpi\+::\+Is\+Finished\+Multi\+Start$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Is Finished (master side) in the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_multi_start_store}{eo\+::mpi\+::\+Multi\+Start\+Store$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Store for the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_multi_start}{eo\+::mpi\+::\+Multi\+Start$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classeo_1_1mpi_1_1_multi_start}{Multi\+Start}} job, created for convenience. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_dummy_get_seeds}{eo\+::mpi\+::\+Dummy\+Get\+Seeds$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Uses the internal default seed generator to get seeds, which means\+: random seeds are sent. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_multiples_of_number}{eo\+::mpi\+::\+Multiples\+Of\+Number$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Sends seeds to the workers, which are multiple of a number given by the master. If no number is given, a random one is used. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_get_random_seeds}{eo\+::mpi\+::\+Get\+Random\+Seeds$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em Returns random seeds to the workers. We can controle which seeds are generated by precising the seed of the master. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_reuse_original_pop_e_a}{eo\+::mpi\+::\+Reuse\+Original\+Pop\+E\+A$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em For a Genetic Algorithm, reinits the population by copying the original one given in constructor, and reinits the continuator. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_reuse_same_pop_e_a}{eo\+::mpi\+::\+Reuse\+Same\+Pop\+E\+A$<$ E\+O\+T $>$}}
\begin{DoxyCompactList}\small\item\em For a Genetic Algorithm, reuses the same population without modifying it after a run. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespaceeo_1_1mpi}{eo\+::mpi}}
\begin{DoxyCompactList}\small\item\em M\+PI parallelization helpers for \mbox{\hyperlink{class_e_o}{EO}}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Contains implementation of a M\+PI job which consists in a multi start, which basically consists in the following\+: the same \mbox{\hyperlink{classeo_algo}{eo\+Algo}} is launched on computers of a clusters, with different seeds for each. As the \mbox{\hyperlink{classeo_algo}{eo\+Algo}} are most of the time stochastics, the results won\textquotesingle{}t be the same. It is fully equivalent to launch the same program but with different seeds.

It follows the structure of a M\+PI job, as described in \mbox{\hyperlink{eo_mpi_8h_source}{eo\+Mpi.\+h}}. The basic algorithm is trivial\+:
\begin{DoxyItemize}
\item Loop while we have a run to perform.
\item Worker performs runs and send their best solution (individual with best fitness) to the master.
\item Master retrieves the best solution and adds it to a \mbox{\hyperlink{classeo_pop}{eo\+Pop}} of best solutions (the user can chooses what he does with this population, for instance\+: retrieve the best element, etc.)
\end{DoxyItemize}

The principal concerns about this algorithm are\+:
\begin{DoxyItemize}
\item How do we reinitialize the algorithm? An \mbox{\hyperlink{classeo_algo}{eo\+Algo}} can have several forms, and initializations have to be performed before each \char`\"{}start\char`\"{}. We can hence decide whether we reinits the population or keep the same population obtained after the previous start, we have to reinitialize continuator, etc. This is customizable in the store.
\item Which seeds should be chosen? If we want the run to be re-\/runnable with the same results, we need to be sure that the seeds are the same. But user can not care about this, and just want random seeds. This is customizable in the store.
\end{DoxyItemize}

These concerns are handled by functors, inheriting from Multi\+Start\+Store$<$\+E\+O\+T$>$\+::\+Reset\+Algo (for the first concern), and Multi\+Start\+Store$<$\+E\+O\+T$>$\+::\+Get\+Seeds (for the second one). There are default implementations, but there is no problem about specializing them or coding your own, by directly inheriting from them. 
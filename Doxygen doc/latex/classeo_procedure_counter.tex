\hypertarget{classeo_procedure_counter}{}\doxysection{eo\+Procedure\+Counter$<$ Procedure $>$ Class Template Reference}
\label{classeo_procedure_counter}\index{eoProcedureCounter$<$ Procedure $>$@{eoProcedureCounter$<$ Procedure $>$}}


{\ttfamily \#include $<$eo\+Counter.\+h$>$}



Inheritance diagram for eo\+Procedure\+Counter$<$ Procedure $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=306pt]{classeo_procedure_counter__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for eo\+Procedure\+Counter$<$ Procedure $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=306pt]{classeo_procedure_counter__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classeo_procedure_counter_a313a33b57f8db70b27ca7b6f9e497151}\label{classeo_procedure_counter_a313a33b57f8db70b27ca7b6f9e497151}} 
{\bfseries eo\+Procedure\+Counter} (Procedure \&\+\_\+proc, std\+::string \+\_\+name=\char`\"{}proc\+\_\+counter\char`\"{})
\item 
Procedure\+::result\+\_\+type \mbox{\hyperlink{classeo_procedure_counter_ac155f6fae5ea5a7dc1b263cdf555ea61}{operator()}} (void)
\item 
\mbox{\Hypertarget{classeo_procedure_counter_a313a33b57f8db70b27ca7b6f9e497151}\label{classeo_procedure_counter_a313a33b57f8db70b27ca7b6f9e497151}} 
{\bfseries eo\+Procedure\+Counter} (Procedure \&\+\_\+proc, std\+::string \+\_\+name=\char`\"{}proc\+\_\+counter\char`\"{})
\item 
Procedure\+::result\+\_\+type \mbox{\hyperlink{classeo_procedure_counter_ac155f6fae5ea5a7dc1b263cdf555ea61}{operator()}} (void)
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class Procedure$>$\newline
class eo\+Procedure\+Counter$<$ Procedure $>$}

\begin{DoxyVerb}Generic counter class that counts the number of times
a procedure is used. Add a procedure through its ctor and
use this class instead of it.
\end{DoxyVerb}


It is derived from \mbox{\hyperlink{classeo_value_param}{eo\+Value\+Param}} so you can add it to a monitor. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classeo_procedure_counter_ac155f6fae5ea5a7dc1b263cdf555ea61}\label{classeo_procedure_counter_ac155f6fae5ea5a7dc1b263cdf555ea61}} 
\index{eoProcedureCounter$<$ Procedure $>$@{eoProcedureCounter$<$ Procedure $>$}!operator()@{operator()}}
\index{operator()@{operator()}!eoProcedureCounter$<$ Procedure $>$@{eoProcedureCounter$<$ Procedure $>$}}
\doxysubsubsection{\texorpdfstring{operator()()}{operator()()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Procedure $>$ \\
Procedure\+::result\+\_\+type \mbox{\hyperlink{classeo_procedure_counter}{eo\+Procedure\+Counter}}$<$ Procedure $>$\+::operator() (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Calls the embedded function and increments the counter

Note for M\+S\+VC users, if this code does not compile, you are quite likely trying to count a function that has a non-\/void return type. Don\textquotesingle{}t look at us, look at the M\+S\+VC builders. Code like \char`\"{}return void;\char`\"{} is perfectly legal according to the A\+N\+SI standard, but the guys at Microsoft didn\textquotesingle{}t get to implementing it yet.

We had two choices\+: assuming (and compiling ) code that returns void or code that returns non-\/void. Given that in \mbox{\hyperlink{class_e_o}{EO}} most functors return void, it was chosen to support void.

But also please let me know if you have a compiler that defines \+\_\+\+M\+S\+C\+\_\+\+V\+ER (lot\textquotesingle{}s of windows compilers do), but is quite capable of compiling return void; type of code. We\textquotesingle{}ll try to change the signature then.

You happy G\+NU (and other compiler) users will not have a problem with this.. \mbox{\Hypertarget{classeo_procedure_counter_ac155f6fae5ea5a7dc1b263cdf555ea61}\label{classeo_procedure_counter_ac155f6fae5ea5a7dc1b263cdf555ea61}} 
\index{eoProcedureCounter$<$ Procedure $>$@{eoProcedureCounter$<$ Procedure $>$}!operator()@{operator()}}
\index{operator()@{operator()}!eoProcedureCounter$<$ Procedure $>$@{eoProcedureCounter$<$ Procedure $>$}}
\doxysubsubsection{\texorpdfstring{operator()()}{operator()()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Procedure $>$ \\
Procedure\+::result\+\_\+type \mbox{\hyperlink{classeo_procedure_counter}{eo\+Procedure\+Counter}}$<$ Procedure $>$\+::operator() (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Calls the embedded function and increments the counter

Note for M\+S\+VC users, if this code does not compile, you are quite likely trying to count a function that has a non-\/void return type. Don\textquotesingle{}t look at us, look at the M\+S\+VC builders. Code like \char`\"{}return void;\char`\"{} is perfectly legal according to the A\+N\+SI standard, but the guys at Microsoft didn\textquotesingle{}t get to implementing it yet.

We had two choices\+: assuming (and compiling ) code that returns void or code that returns non-\/void. Given that in \mbox{\hyperlink{class_e_o}{EO}} most functors return void, it was chosen to support void.

But also please let me know if you have a compiler that defines \+\_\+\+M\+S\+C\+\_\+\+V\+ER (lot\textquotesingle{}s of windows compilers do), but is quite capable of compiling return void; type of code. We\textquotesingle{}ll try to change the signature then.

You happy G\+NU (and other compiler) users will not have a problem with this.. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
deprecated/eo/src/eo\+Counter.\+h\end{DoxyCompactItemize}

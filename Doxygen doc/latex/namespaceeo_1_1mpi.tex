\hypertarget{namespaceeo_1_1mpi}{}\doxysection{eo\+::mpi Namespace Reference}
\label{namespaceeo_1_1mpi}\index{eo::mpi@{eo::mpi}}


M\+PI parallelization helpers for \mbox{\hyperlink{class_e_o}{EO}}.  


\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespaceeo_1_1mpi_1_1_channel}{Channel}}
\begin{DoxyCompactList}\small\item\em Tags used in M\+PI messages for framework communication. \end{DoxyCompactList}\item 
 \mbox{\hyperlink{namespaceeo_1_1mpi_1_1_message}{Message}}
\begin{DoxyCompactList}\small\item\em Simple orders used by the framework. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_assignment_algorithm}{Assignment\+Algorithm}}
\begin{DoxyCompactList}\small\item\em Contains informations on the available workers and allows to find assignees for jobs. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_dummy_get_seeds}{Dummy\+Get\+Seeds}}
\begin{DoxyCompactList}\small\item\em Uses the internal default seed generator to get seeds, which means\+: random seeds are sent. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_dummy_handle_response_function}{Dummy\+Handle\+Response\+Function}}
\begin{DoxyCompactList}\small\item\em Handle response functor which does nothing. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_dummy_is_finished_function}{Dummy\+Is\+Finished\+Function}}
\begin{DoxyCompactList}\small\item\em Is finished functor which returns true everytime. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_dummy_job_store}{Dummy\+Job\+Store}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classeo_1_1mpi_1_1_job}{Job}} store containing all dummy functors and containing no data. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_dummy_process_task_function}{Dummy\+Process\+Task\+Function}}
\begin{DoxyCompactList}\small\item\em Process task functor which does nothing. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_dummy_send_task_function}{Dummy\+Send\+Task\+Function}}
\begin{DoxyCompactList}\small\item\em Send task functor which does nothing. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_dynamic_assignment_algorithm}{Dynamic\+Assignment\+Algorithm}}
\begin{DoxyCompactList}\small\item\em Assignment (scheduling) algorithm which handles workers in a queue. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_empty_job}{Empty\+Job}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classeo_1_1mpi_1_1_job}{Job}} to run after a Multi \mbox{\hyperlink{classeo_1_1mpi_1_1_job}{Job}}, so as to indicate that every workers should terminate. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_get_random_seeds}{Get\+Random\+Seeds}}
\begin{DoxyCompactList}\small\item\em Returns random seeds to the workers. We can controle which seeds are generated by precising the seed of the master. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_handle_response_function}{Handle\+Response\+Function}}
\begin{DoxyCompactList}\small\item\em Functor (master side) used to indicate what to do when receiving a response. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_handle_response_multi_start}{Handle\+Response\+Multi\+Start}}
\begin{DoxyCompactList}\small\item\em Handle Response (master side) in the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_handle_response_parallel_apply}{Handle\+Response\+Parallel\+Apply}}
\begin{DoxyCompactList}\small\item\em Handle response functor implementation for the parallel apply (map) job. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_is_finished_function}{Is\+Finished\+Function}}
\begin{DoxyCompactList}\small\item\em Functor (master side) indicating whether the job is done or not. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_is_finished_multi_start}{Is\+Finished\+Multi\+Start}}
\begin{DoxyCompactList}\small\item\em Is Finished (master side) in the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_is_finished_parallel_apply}{Is\+Finished\+Parallel\+Apply}}
\begin{DoxyCompactList}\small\item\em Is finished functor implementation for the parallel apply (map) job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_job}{Job}}
\begin{DoxyCompactList}\small\item\em Class implementing the centralized job algorithm. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_job_store}{Job\+Store}}
\begin{DoxyCompactList}\small\item\em Contains all the required data and the functors to launch a job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_multi_job}{Multi\+Job}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classeo_1_1mpi_1_1_job}{Job}} that will be launched an unknown amount of times, in worker side. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_multiples_of_number}{Multiples\+Of\+Number}}
\begin{DoxyCompactList}\small\item\em Sends seeds to the workers, which are multiple of a number given by the master. If no number is given, a random one is used. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_multi_start}{Multi\+Start}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classeo_1_1mpi_1_1_multi_start}{Multi\+Start}} job, created for convenience. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_multi_start_data}{Multi\+Start\+Data}}
\begin{DoxyCompactList}\small\item\em Data used by the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_multi_start_store}{Multi\+Start\+Store}}
\begin{DoxyCompactList}\small\item\em Store for the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_node}{Node}}
\begin{DoxyCompactList}\small\item\em Global object used to reach \mbox{\hyperlink{classmpi_1_1communicator}{mpi\+::communicator}} everywhere. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_one_shot_job}{One\+Shot\+Job}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classeo_1_1mpi_1_1_job}{Job}} that will be launched only once. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_parallel_apply}{Parallel\+Apply}}
\begin{DoxyCompactList}\small\item\em Parallel apply job. Present for convenience only. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_parallel_apply_assignment}{Parallel\+Apply\+Assignment}}
\begin{DoxyCompactList}\small\item\em Structure used to save assignment to a worker, i.\+e which slice of the table it has to process. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_parallel_apply_data}{Parallel\+Apply\+Data}}
\begin{DoxyCompactList}\small\item\em Data useful for a parallel apply (map). \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_parallel_apply_store}{Parallel\+Apply\+Store}}
\begin{DoxyCompactList}\small\item\em Store containing all the datas and the functors for the parallel apply (map) job. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_process_task_function}{Process\+Task\+Function}}
\begin{DoxyCompactList}\small\item\em Functor (worker side) implementing the processing to do. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_process_task_multi_start}{Process\+Task\+Multi\+Start}}
\begin{DoxyCompactList}\small\item\em Process Task (worker side) in the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_process_task_parallel_apply}{Process\+Task\+Parallel\+Apply}}
\begin{DoxyCompactList}\small\item\em Process task functor implementation for the parallel apply (map) job. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_reuse_original_pop_e_a}{Reuse\+Original\+Pop\+EA}}
\begin{DoxyCompactList}\small\item\em For a Genetic Algorithm, reinits the population by copying the original one given in constructor, and reinits the continuator. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_reuse_same_pop_e_a}{Reuse\+Same\+Pop\+EA}}
\begin{DoxyCompactList}\small\item\em For a Genetic Algorithm, reuses the same population without modifying it after a run. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_send_task_function}{Send\+Task\+Function}}
\begin{DoxyCompactList}\small\item\em Functor (master side) used to send a task to the worker. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_send_task_multi_start}{Send\+Task\+Multi\+Start}}
\begin{DoxyCompactList}\small\item\em Send task (master side) in the Multi Start job. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classeo_1_1mpi_1_1_send_task_parallel_apply}{Send\+Task\+Parallel\+Apply}}
\begin{DoxyCompactList}\small\item\em Send task functor implementation for the parallel apply (map) job. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_shared_data_function}{Shared\+Data\+Function}}
\begin{DoxyCompactList}\small\item\em Base class for the 4 algorithm functors. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structeo_1_1mpi_1_1_static_assignment_algorithm}{Static\+Assignment\+Algorithm}}
\begin{DoxyCompactList}\small\item\em Assignment algorithm which gives to each worker a precise number of tasks to do, in a round robin fashion. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceeo_1_1mpi_a4901bcdfc2aaf35b70c4fe172bc04a49}\label{namespaceeo_1_1mpi_a4901bcdfc2aaf35b70c4fe172bc04a49}} 
\mbox{\hyperlink{classeo_timer_stat}{eo\+Timer\+Stat}} \mbox{\hyperlink{namespaceeo_1_1mpi_a4901bcdfc2aaf35b70c4fe172bc04a49}{timer\+Stat}}
\begin{DoxyCompactList}\small\item\em A timer which allows user to generate statistics about computation times. \end{DoxyCompactList}\item 
const int \mbox{\hyperlink{group___m_p_i_gafbb77faa1fc663490460f631906a3099}{D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+A\+S\+T\+ER}} = 0
\begin{DoxyCompactList}\small\item\em If the job only has one master, the user can use this constant, so as not to worry with integer ids. \end{DoxyCompactList}\item 
const int \mbox{\hyperlink{group___m_p_i_ga278419db2678de33e623416b129c323c}{R\+E\+S\+T\+\_\+\+O\+F\+\_\+\+T\+H\+E\+\_\+\+W\+O\+R\+LD}} = -\/1
\begin{DoxyCompactList}\small\item\em Constant indicating to use all the resting available workers, in assignment algorithms constructor using an interval. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
M\+PI parallelization helpers for \mbox{\hyperlink{class_e_o}{EO}}. 

This namespace contains parallelization functions which help to parallelize computations in \mbox{\hyperlink{class_e_o}{EO}}. It is based on a generic algorithm, which is then customized with functors, corresponding to the algorithm main steps. These computations are centralized, i.\+e there is one central host whose role is to handle the steps of the algorithm ; we call it the \char`\"{}master\char`\"{}. The other hosts just have to perform a \char`\"{}dummy\char`\"{} computation, which may be any kind of processing ; we call them, the \char`\"{}slaves\char`\"{}, or less pejoratively, the \char`\"{}workers\char`\"{}. Workers can communicate to each other, but they receive their orders from the Master and send him back some results. A worker can also be the master of a different parallelization process, as soon as it is a part of its work. Machines of the network, also called hosts, are identified by an unique number\+: their rank. At any time during the execution of the program, all the hosts know the total number of hosts.

A parallelized \mbox{\hyperlink{classeo_1_1mpi_1_1_job}{Job}} is a set of tasks which are independant (i.\+e can be executed in random order without modifiying the result) and take a data input and compute a data output to be sent to the Master. The data can be of any type, however they have to be serialized to be sent over a network. It is sufficient that they can be serialized through boost.

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000030}{Todo}}]For serialization purposes, don\textquotesingle{}t depend upon boost. It would be easy to use only eoserial and send strings via mpi.\end{DoxyRefDesc}


The main steps of the algorithm are the following\+:
\begin{DoxyItemize}
\item For the master\+:
\begin{DoxyItemize}
\item Have we done with the treatment we are doing ?
\item If this is the case, we can quit.
\item Otherwise, send an input data to some available worker.
\item If there\textquotesingle{}s no available worker, wait for a worker to be free.
\item When receiving the response, handle it (eventually compute something on the output data, store it...).
\item Go back to the first step.
\end{DoxyItemize}
\item For the worker, it is even easier\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{struct_wait}{Wait}} for an order.
\item If there\textquotesingle{}s nothing to do, just quit.
\item Otherwise, eventually retrieve data and do the work.
\item Go back to the first step.
\end{DoxyItemize}
\end{DoxyItemize}

There is of course some network adjustements to do and precisions to give there, but the main ideas are present. As the job is fully centralized, this is the master who tells the workers when to quit and when to work.

The idea behind these M\+PI helpers is to be the most generic possible. If we look back at the steps of the algorithm, we found that the steps can be splitted into 2 parts\+: the first consists in the steps of any parallelization algorithm and the other consists in the specific parts of the algorithm. Ideally, the user should just have to implement the specific parts of the algorithm. We identified these parts to be\+:
\begin{DoxyItemize}
\item For the master\+:
\begin{DoxyItemize}
\item What does mean to have terminated ? There are only two alternatives, in our binary world\+: either it is terminated, or it is not. Hence we only need a function returning a boolean to know if we\textquotesingle{}re done with the computation \+: we\textquotesingle{}ll call it Is\+Finished.
\item What do we have to do when we send a task ? We don\textquotesingle{}t have any a priori on the form of the sent data, or the number of sent data. Moreover, as the tasks are all independant, we don\textquotesingle{}t care of who will do the computation, as soon as it\textquotesingle{}s done. Knowing the rank of the worker will be sufficient to send him data. We have identified another function, taking a single argument which is the rank of the worker\+: we\textquotesingle{}ll call it Send\+Task.
\item What do we have to do when we receive a response from a worker ? One more time, we don\textquotesingle{}t know which form or structure can have the receive data, only the user can know. Also we let the user the charge to retrieve the data ; he just has to know from who the master will retrieve the data. Here is another function, taking a rank (the sender\textquotesingle{}s one) as a function argument \+: this will be Handle\+Response.
\end{DoxyItemize}
\item For the worker\+:
\begin{DoxyItemize}
\item What is the processing ? It can have any nature. We just need to be sure that a data is sent back to the master, but it seems difficult to check that\+: it will be the role of the user to assert that data is sent by the worker at the end of an execution. We\textquotesingle{}ve got identified our last function\+: Process\+Task.
\end{DoxyItemize}
\end{DoxyItemize}

In term of implementation, it would be annoying to have only abstract classes with these 4 methods to implement. It would mean that if you want to alter just one of these 4 functions, you have to implement a new sub class, with a new constructor which could have the same signature. Besides, this fashion doesn\textquotesingle{}t allow you to add dynamic functionalities, using the design pattern Decorator for instance, without implement a class for each type of decoration you want to add. For these reasons, we decided to transform function into functors ; the user can then wrap the existing, basic comportments into more sophisticated computations, whenever he wants, and without the notion of order. We retrieve here the power of extension given by the design pattern Decorator.

Our 4 functors could have a big amount of data in common (see eo\+Parallel\+Apply to have an idea). So as to make it easy for the user to implement these 4 functors, we consider that these functors have to share a common data structure. This data structure is referenced (as a pointer) in the 4 functors, so the user doesn\textquotesingle{}t need to pass a lot of parameters to each functor constructor.

There are two kinds of jobs\+:
\begin{DoxyItemize}
\item The job which are launched a fixed and well known amount of times, i.\+e both master and workers know how many times they will be launched. They are \char`\"{}one shot jobs\char`\"{}.
\item The job which are launched an unknown amount of times, for instance embedded in a while loop for which we don\textquotesingle{}t know the amount of repetitions (typically, \mbox{\hyperlink{classeo_easy_e_a}{eo\+Easy\+EA}} loop is a good example, as we don\textquotesingle{}t know the continuator condition). They are called \char`\"{}multi job\char`\"{}. As the master tells the workers to quit, we have to differentiate these two kinds of jobs. When the job is of the kind \char`\"{}multi job\char`\"{}, the workers would have to perform a while(true) loop so as to receive the orders ; but even if the master tells them to quit, they would begin another job and wait for another order, while the master would have quit\+: this would cause a deadlock and workers processes would be blocked, waiting for an order. 
\end{DoxyItemize}
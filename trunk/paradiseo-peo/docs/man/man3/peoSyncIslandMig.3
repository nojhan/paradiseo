.TH "peoSyncIslandMig" 3 "7 Jan 2007" "Version 0.1" "ParadisEO-PEO" \" -*- nroff -*-
.ad l
.nh
.SH NAME
peoSyncIslandMig \- The \fBpeoSyncIslandMig\fP class offers the elementary basis for implementating a synchronous island migration model - requires the specification of several basic parameters, i.e.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <peoSyncIslandMig.h>\fP
.PP
Inherits \fBCooperative\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBpeoSyncIslandMig\fP (unsigned __frequency, eoSelect< EOT > &__select, eoReplacement< EOT > &__replace, \fBTopology\fP &__topology, eoPop< EOT > &__source, eoPop< EOT > &__destination)"
.br
.RI "\fIConstructor for the \fBpeoSyncIslandMig\fP class; the characteristics of the migration model are defined through the specified parameters - out of the box objects provided in EO, etc., or custom, derived objects may be passed as parameters. \fP"
.ti -1c
.RI "void \fBoperator()\fP ()"
.br
.RI "\fIFunction operator to be called as checkpoint for performing the migration step. \fP"
.ti -1c
.RI "void \fBpack\fP ()"
.br
.RI "\fIAuxiliary function dealing with sending the emigrant individuals. There is no need to explicitly call the function. \fP"
.ti -1c
.RI "void \fBunpack\fP ()"
.br
.RI "\fIAuxiliary function dealing with receiving immigrant individuals. There is no need to explicitly call the function. \fP"
.ti -1c
.RI "void \fBnotifySending\fP ()"
.br
.RI "\fIAuxiliary function dealing with migration notifications. There is no need to explicitly call the function. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBemigrate\fP ()"
.br
.ti -1c
.RI "void \fBimmigrate\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "eoPeriodicContinue< EOT > \fBcont\fP"
.br
.ti -1c
.RI "eoSelect< EOT > & \fBselect\fP"
.br
.ti -1c
.RI "eoReplacement< EOT > & \fBreplace\fP"
.br
.ti -1c
.RI "\fBTopology\fP & \fBtopology\fP"
.br
.ti -1c
.RI "eoPop< EOT > & \fBsource\fP"
.br
.ti -1c
.RI "eoPop< EOT > & \fBdestination\fP"
.br
.ti -1c
.RI "std::queue< eoPop< EOT > > \fBimm\fP"
.br
.ti -1c
.RI "std::queue< eoPop< EOT > > \fBem\fP"
.br
.ti -1c
.RI "std::queue< \fBCooperative\fP * > \fBcoop_em\fP"
.br
.ti -1c
.RI "sem_t \fBsync\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class EOT> class peoSyncIslandMig< EOT >"
The \fBpeoSyncIslandMig\fP class offers the elementary basis for implementating a synchronous island migration model - requires the specification of several basic parameters, i.e. 

frequency of the migrations, selection and replacement strategies, a topological model and the source and destination population for the migrating individuals. The main difference as opposed to the asynchronous migration model is the synchronization step performed after selecting and sending the emigrant individuals.
.PP
The migration operator is called at the end of each generation of an evolutionary algorithms as a checkpoint object - the following code exposes the structure of a classic evolutionary algorithm:
.PP
\fBdo\fP {               select( population, offsprings );   // select the offsprings from the current population          transform( offsprings );   // crossover and mutation operators are applied on the selected offsprings          evaluate( offsprings );   // evaluation step of the resulting offspring          replace( population, offsprings );   // replace the individuals in the current population whith individuals from the offspring population, according to a specified replacement strategy } \fBwhile\fP ( eaCheckpointContinue( population ) );   // checkpoint operators are applied on the current population, including the migration operator, if any specified  
.PP
Constructing a synchronous island migration model requires having defined (1) a topological migration model, (2) the control parameters of the migration process, (3) a checkpoint object associated with an evolutionary algorithm, and (4) an owner object must be set. The owner object must be derived from the \fB\fBRunner\fP\fP class (for example a \fBpeoEA\fP object represents a possible owner). A simple example is offered bellow:
.PP
.PD 0
.IP "1." 4
topological model to be followed when performing migrations: 
.br
 
.br
 \fBRingTopology\fP migTopology;   // a simple ring topological model - each island communicates with two other islands 
.PP

.IP "2." 4
the continuation criterion, selection and replacement strategy etc. are defined: 
.br
 
.br
 eoPop< EOT > population( POP_SIZE, popInitializer );   // population of individuals to be used for the evolutionary algorithm       eoRandomSelect< EOT > migSelectStrategy;   // selection strategy - in this case a random selection is applied eoSelectNumber< EOT > migSelect( migSelectStrategy, MIG_SIZE );   // number of individuals to be selected using the specified strategy eoPlusReplacement< EOT > migReplace;   // immigration strategy - the worse individuals in the destination population are replaced by the immigrant individuals       peoSyncIslandMig< EOT > syncMigration( 
.br
          MIG_FREQ, migSelect, migReplace, migTopology, 
.br
          population, population 
.br
 );    // synchronous migration object - the emigrant individuals are selected from the same from population in which the immigrant individuals are being integrated  
.PP

.IP "3." 4
creation of a checkpoint object as part of the definition of an evolutionary algoritm (details of th EA not given as being out of scope): 
.br
 
.br
 ...      eoGenContinue< EOT > eaCont( NUM_GEN );   // the evolutionary algorithm will stop after NUM_GEN generations eoCheckPoint< EOT > eaCheckpointContinue( eaCont );   // number of individuals to be selected using the specified strategy ...      eaCheckpointContinue.add( syncMigration );   // adding the migration operator as checkpoint element ...      
.PP

.IP "4." 4
definition of an owner evolutionary algorithm (an object inheriting the \fB\fBRunner\fP\fP class): 
.br
 
.br
 peoEA< EOT > eaAlg( eaCheckpointContinue, eaPopEval, eaSelect, eaTransform, eaReplace);   // evolutionary algorithm having as checkpoint the eaCheckpointContinue object defined above  syncMigration.setOwner( eaAlg );   // setting the evolutionary algorithm as owner of the migration object  eaAlg( population );   // applying the evolutionary algorithm on a given population  
.PP
.PP
The source and the destination population for the migration object were specified as being the same, in step no. 2, as we are usually interested in selecting the emigrants and integrating the immigrant individuals from and in, respectively, one unique population, iteratively evolved by an evolutionary algorithm. There is no restriction in having two distinct populations as source and destination for the emigrant and immigrant individuals respectively.
.PP
The above steps only create a synchronous migration object associated to an evolutionary algorithm. The creation of several islands requires the reiteration of the steps 2 through 4 for creating distinct algorithms, with distinct populations and the associated distinctly parametrized migration objects. The interconnecting element is the underlying topology, defined at step 1 (the same C++ migTopology object has to be passed as parameter for all the migration objects, in order to interconnect them). 
.PP
Definition at line 129 of file peoSyncIslandMig.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class EOT> \fBpeoSyncIslandMig\fP< EOT >::\fBpeoSyncIslandMig\fP (unsigned __frequency, eoSelect< EOT > & __select, eoReplacement< EOT > & __replace, \fBTopology\fP & __topology, eoPop< EOT > & __source, eoPop< EOT > & __destination)"
.PP
Constructor for the \fBpeoSyncIslandMig\fP class; the characteristics of the migration model are defined through the specified parameters - out of the box objects provided in EO, etc., or custom, derived objects may be passed as parameters. 
.PP
\fBParameters:\fP
.RS 4
\fIunsigned\fP __frequency - frequency of the migrations - the migrations occur periodically; 
.br
\fIeoSelect<\fP EOT >& __select - selection strategy to be applied for constructing a list of emigrant individuals out of the source population; 
.br
\fIeoReplacement<\fP EOT >& __replace - replacement strategy used for integrating the immigrant individuals in the destination population; 
.br
\fITopology&\fP __topology - topological model to be followed when performing migrations; 
.br
\fIeoPop<\fP EOT >& __source - source population from which the emigrant individuals are selected; 
.br
\fIeoPop<\fP EOT >& __destination - destination population in which the immigrant population are integrated. 
.RE
.PP

.PP
Definition at line 193 of file peoSyncIslandMig.h.
.PP
References Topology::add(), and peoSyncIslandMig< EOT >::sync.
.SH "Member Function Documentation"
.PP 
.SS "template<class EOT> void \fBpeoSyncIslandMig\fP< EOT >::operator() ()"
.PP
Function operator to be called as checkpoint for performing the migration step. 
.PP
The emigrant individuals are selected from the source population and sent to the next island (defined by the topology object) while the immigrant individuals are integrated in the destination population. There is no need to explicitly call the function - the wrapper checkpoint object (please refer to the above example) will perform the call when required. 
.PP
Definition at line 267 of file peoSyncIslandMig.h.
.PP
References peoSyncIslandMig< EOT >::cont, peoSyncIslandMig< EOT >::emigrate(), Cooperative::getOwner(), peoSyncIslandMig< EOT >::immigrate(), Thread::setActive(), peoSyncIslandMig< EOT >::source, Communicable::stop(), and peoSyncIslandMig< EOT >::sync.

.SH "Author"
.PP 
Generated automatically by Doxygen for ParadisEO-PEO from the source code.
